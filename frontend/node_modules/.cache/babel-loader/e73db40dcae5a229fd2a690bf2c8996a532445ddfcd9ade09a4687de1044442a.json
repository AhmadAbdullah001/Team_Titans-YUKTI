{"ast":null,"code":"import { Interface } from \"ethers\";\nimport { ethers } from \"ethers\";\nimport { ensureContractCode, ensureCorrectNetwork, ensureWalletConnected, getBrowserProvider, getContractRuntimeConfig, getReadOnlyContract, getWriteContract } from \"./eth.js\";\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return {\n    contract,\n    signerAddress\n  };\n}\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\nasync function findEVaultPropertiesByHash(hash) {\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) return [];\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const {\n    contractAddress\n  } = getContractRuntimeConfig();\n  const evaultReader = new ethers.Contract(contractAddress, [\"function propertyCounter() view returns (uint256)\", \"function properties(uint256) view returns (uint256 id,address owner,string ipfsHash,bool registrarApproved,bool notaryApproved,bool authorityApproved,uint256 approvalCount,uint8 status,bool bankVerified)\"], provider);\n  let count = 0;\n  try {\n    count = Number(await evaultReader.propertyCounter());\n  } catch {\n    return [];\n  }\n  const matches = [];\n  for (let i = 1; i <= count; i += 1) {\n    try {\n      const row = await evaultReader.properties(i);\n      const rowHash = String((row === null || row === void 0 ? void 0 : row.ipfsHash) || \"\").trim();\n      if (rowHash && rowHash === normalizedHash) {\n        matches.push({\n          id: Number(row.id || i),\n          owner: String(row.owner || \"\"),\n          ipfsHash: rowHash,\n          status: Number(row.status || 0),\n          approvalCount: Number(row.approvalCount || 0)\n        });\n      }\n    } catch {\n      // continue scan\n    }\n  }\n  return matches;\n}\nasync function findEVaultPropertyByHash(hash, preferredOwner = \"\") {\n  const matches = await findEVaultPropertiesByHash(hash);\n  if (!matches.length) return null;\n  const normalizedPreferredOwner = String(preferredOwner || \"\").trim().toLowerCase();\n  if (normalizedPreferredOwner) {\n    const owned = matches.filter(m => String(m.owner || \"\").toLowerCase() === normalizedPreferredOwner).sort((a, b) => b.id - a.id);\n    if (owned.length) return owned[0];\n  }\n\n  // Prefer latest registered record; otherwise latest id.\n  const registered = matches.filter(m => Number(m.status) === 2).sort((a, b) => b.id - a.id);\n  if (registered.length) return registered[0];\n  return matches.sort((a, b) => b.id - a.id)[0];\n}\nexport async function getPropertyStateOnChain(hash, preferredOwner = \"\") {\n  const property = await findEVaultPropertyByHash(hash, preferredOwner);\n  if (!property) {\n    throw new Error(\"Property hash was not found on-chain.\");\n  }\n  return property;\n}\nexport async function registerPropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`);\n  }\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\nexport async function pushHashOnChainWithWallet(hash, intendedOwner = \"\") {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const signerAddress = String(await signer.getAddress()).toLowerCase();\n  const {\n    contractAddress\n  } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedIntendedOwner = String(intendedOwner || \"\").trim().toLowerCase();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  const attempts = [\"function requestRegistration(string ipfsHash)\", \"function registerProperty(string hash)\", \"function storeHash(string _hash)\"];\n  let lastError = null;\n  let registrationTxHash = \"\";\n  for (const fragment of attempts) {\n    try {\n      var _fragment$match;\n      const iface = new Interface([fragment]);\n      const fn = String(((_fragment$match = fragment.match(/function\\s+([^(]+)/)) === null || _fragment$match === void 0 ? void 0 : _fragment$match[1]) || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({\n        to: contractAddress,\n        data\n      });\n      await tx.wait();\n      registrationTxHash = tx.hash;\n      break;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n  if (!registrationTxHash) {\n    var _lastError, _lastError2, _lastError3;\n    throw new Error(`Wallet chain push failed: ${String(((_lastError = lastError) === null || _lastError === void 0 ? void 0 : _lastError.reason) || ((_lastError2 = lastError) === null || _lastError2 === void 0 ? void 0 : _lastError2.shortMessage) || ((_lastError3 = lastError) === null || _lastError3 === void 0 ? void 0 : _lastError3.message) || \"unknown error\")}`);\n  }\n\n  // If reviewer wallet pushed the hash, transfer ownership to intended owner immediately.\n  if (normalizedIntendedOwner && ethers.isAddress(normalizedIntendedOwner) && normalizedIntendedOwner !== signerAddress) {\n    var _transferError, _transferError2, _transferError3;\n    let transferError = null;\n    try {\n      const iface = new Interface([\"function transferProperty(string hash, address newOwner)\"]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [normalizedHash, normalizedIntendedOwner]);\n      const tx = await signer.sendTransaction({\n        to: contractAddress,\n        data\n      });\n      await tx.wait();\n      return {\n        registrationTxHash,\n        transferTxHash: tx.hash\n      };\n    } catch (error) {\n      transferError = error;\n    }\n\n    // eVault fallback: transferProperty(uint256,address)\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash, signerAddress);\n      if (property !== null && property !== void 0 && property.id) {\n        const iface = new Interface([\"function transferProperty(uint256 propertyId, address newOwner)\"]);\n        const data = iface.encodeFunctionData(\"transferProperty\", [property.id, normalizedIntendedOwner]);\n        const tx = await signer.sendTransaction({\n          to: contractAddress,\n          data\n        });\n        await tx.wait();\n        return {\n          registrationTxHash,\n          transferTxHash: tx.hash\n        };\n      }\n    } catch (fallbackError) {\n      transferError = fallbackError;\n    }\n    throw new Error(`Hash pushed, but owner transfer to intended wallet failed: ${String(((_transferError = transferError) === null || _transferError === void 0 ? void 0 : _transferError.reason) || ((_transferError2 = transferError) === null || _transferError2 === void 0 ? void 0 : _transferError2.shortMessage) || ((_transferError3 = transferError) === null || _transferError3 === void 0 ? void 0 : _transferError3.message) || \"unknown error\")}`);\n  }\n  return {\n    registrationTxHash,\n    transferTxHash: \"\"\n  };\n}\nexport async function approvePropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`);\n  }\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    try {\n      return await contract.documentOwner(hash);\n    } catch {\n      const property = await findEVaultPropertyByHash(hash);\n      return (property === null || property === void 0 ? void 0 : property.owner) || \"0x0000000000000000000000000000000000000000\";\n    }\n  }\n}\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return {\n      txHash: tx.hash,\n      from: signerAddress,\n      to: normalizedOwner\n    };\n  } catch (error) {\n    // Fallback for eVault contract that uses transferProperty(uint256,address).\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash, signerAddress);\n      if (!(property !== null && property !== void 0 && property.id)) {\n        throw new Error(\"Property hash not found in eVault contract.\");\n      }\n      const iface = new Interface([\"function transferProperty(uint256 propertyId, address newOwner)\"]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [property.id, normalizedOwner]);\n      const tx = await contract.runner.sendTransaction({\n        to: contract.target,\n        data\n      });\n      await tx.wait();\n      return {\n        txHash: tx.hash,\n        from: signerAddress,\n        to: normalizedOwner\n      };\n    } catch (fallbackError) {\n      const fallbackMessage = String((fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.reason) || (fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.shortMessage) || (fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.message) || \"\");\n      if (fallbackMessage.includes(\"Only current owner\")) {\n        throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n      }\n      if (fallbackMessage.includes(\"Invalid owner\") || fallbackMessage.includes(\"Invalid new owner\")) {\n        throw new Error(\"Invalid recipient wallet address.\");\n      }\n      if (fallbackMessage.includes(\"Property hash not found in eVault contract\")) {\n        throw new Error(\"Property hash was not found on-chain.\");\n      }\n    }\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\");\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    if (message.includes(\"CALL_EXCEPTION\") || message.includes(\"execution reverted\") || message.includes(\"require(false)\")) {\n      throw new Error(\"Transfer failed due to contract function mismatch or missing on-chain property.\");\n    }\n    throw error;\n  }\n}\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map(r => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp)\n  }));\n}\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\nexport async function getWalletRoleOnChain() {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([contract.registrars(signerAddress), contract.admin()]);\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase()\n  };\n}\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data\n  });\n  await tx.wait();\n  return tx.hash;\n}\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}","map":{"version":3,"names":["Interface","ethers","ensureContractCode","ensureCorrectNetwork","ensureWalletConnected","getBrowserProvider","getContractRuntimeConfig","getReadOnlyContract","getWriteContract","getWriteReadyContract","provider","signer","getSigner","contract","signerAddress","getAddress","getReadReadyContract","findEVaultPropertiesByHash","hash","normalizedHash","String","trim","contractAddress","evaultReader","Contract","count","Number","propertyCounter","matches","i","row","properties","rowHash","ipfsHash","push","id","owner","status","approvalCount","findEVaultPropertyByHash","preferredOwner","length","normalizedPreferredOwner","toLowerCase","owned","filter","m","sort","a","b","registered","getPropertyStateOnChain","property","Error","registerPropertyOnChain","isRegistrar","registrars","exists","verifyHash","tx","registerProperty","wait","error","message","reason","shortMessage","includes","storeHash","pushHashOnChainWithWallet","intendedOwner","normalizedIntendedOwner","attempts","lastError","registrationTxHash","fragment","_fragment$match","iface","fn","match","data","encodeFunctionData","sendTransaction","to","_lastError","_lastError2","_lastError3","isAddress","_transferError","_transferError2","_transferError3","transferError","transferTxHash","fallbackError","approvePropertyOnChain","approveProperty","verifyPropertyOnChain","verifyProperty","propertyExistsOnChain","getOwner","getPropertyOwnerOnChain","documentOwner","transferPropertyOnChain","newOwner","normalizedOwner","transferProperty","txHash","from","runner","target","fallbackMessage","getPropertyHistoryOnChain","records","getPropertyHistory","map","r","timestamp","getAllPropertiesOnChain","getAllProperties","getWalletRoleOnChain","adminAddress","Promise","all","admin","wallet","Boolean","isAdmin","grantRegistrarOnChain","registrarAddress","addRegistrar","revokeRegistrarOnChain","normalized","isWalletRegistrarOnChain","walletAddress","getAdminAddressOnChain","getRegistrarStatusOnChain"],"sources":["C:/Users/ahmad/OneDrive/Desktop/evault/frontend/src/contract/propertyActions.js"],"sourcesContent":["import { Interface } from \"ethers\";\nimport { ethers } from \"ethers\";\nimport {\n  ensureContractCode,\n  ensureCorrectNetwork,\n  ensureWalletConnected,\n  getBrowserProvider,\n  getContractRuntimeConfig,\n  getReadOnlyContract,\n  getWriteContract,\n} from \"./eth.js\";\n\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return { contract, signerAddress };\n}\n\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\n\nasync function findEVaultPropertiesByHash(hash) {\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) return [];\n\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const { contractAddress } = getContractRuntimeConfig();\n\n  const evaultReader = new ethers.Contract(\n    contractAddress,\n    [\n      \"function propertyCounter() view returns (uint256)\",\n      \"function properties(uint256) view returns (uint256 id,address owner,string ipfsHash,bool registrarApproved,bool notaryApproved,bool authorityApproved,uint256 approvalCount,uint8 status,bool bankVerified)\",\n    ],\n    provider\n  );\n\n  let count = 0;\n  try {\n    count = Number(await evaultReader.propertyCounter());\n  } catch {\n    return [];\n  }\n\n  const matches = [];\n  for (let i = 1; i <= count; i += 1) {\n    try {\n      const row = await evaultReader.properties(i);\n      const rowHash = String(row?.ipfsHash || \"\").trim();\n      if (rowHash && rowHash === normalizedHash) {\n        matches.push({\n          id: Number(row.id || i),\n          owner: String(row.owner || \"\"),\n          ipfsHash: rowHash,\n          status: Number(row.status || 0),\n          approvalCount: Number(row.approvalCount || 0),\n        });\n      }\n    } catch {\n      // continue scan\n    }\n  }\n\n  return matches;\n}\n\nasync function findEVaultPropertyByHash(hash, preferredOwner = \"\") {\n  const matches = await findEVaultPropertiesByHash(hash);\n  if (!matches.length) return null;\n\n  const normalizedPreferredOwner = String(preferredOwner || \"\").trim().toLowerCase();\n  if (normalizedPreferredOwner) {\n    const owned = matches\n      .filter((m) => String(m.owner || \"\").toLowerCase() === normalizedPreferredOwner)\n      .sort((a, b) => b.id - a.id);\n    if (owned.length) return owned[0];\n  }\n\n  // Prefer latest registered record; otherwise latest id.\n  const registered = matches\n    .filter((m) => Number(m.status) === 2)\n    .sort((a, b) => b.id - a.id);\n  if (registered.length) return registered[0];\n\n  return matches.sort((a, b) => b.id - a.id)[0];\n}\n\nexport async function getPropertyStateOnChain(hash, preferredOwner = \"\") {\n  const property = await findEVaultPropertyByHash(hash, preferredOwner);\n  if (!property) {\n    throw new Error(\"Property hash was not found on-chain.\");\n  }\n  return property;\n}\n\nexport async function registerPropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`\n    );\n  }\n\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\n\nexport async function pushHashOnChainWithWallet(hash, intendedOwner = \"\") {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const signerAddress = String(await signer.getAddress()).toLowerCase();\n  const { contractAddress } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedIntendedOwner = String(intendedOwner || \"\").trim().toLowerCase();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n\n  const attempts = [\n    \"function requestRegistration(string ipfsHash)\",\n    \"function registerProperty(string hash)\",\n    \"function storeHash(string _hash)\",\n  ];\n\n  let lastError = null;\n  let registrationTxHash = \"\";\n  for (const fragment of attempts) {\n    try {\n      const iface = new Interface([fragment]);\n      const fn = String(fragment.match(/function\\s+([^(]+)/)?.[1] || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({ to: contractAddress, data });\n      await tx.wait();\n      registrationTxHash = tx.hash;\n      break;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n\n  if (!registrationTxHash) {\n    throw new Error(\n      `Wallet chain push failed: ${String(\n        lastError?.reason || lastError?.shortMessage || lastError?.message || \"unknown error\"\n      )}`\n    );\n  }\n\n  // If reviewer wallet pushed the hash, transfer ownership to intended owner immediately.\n  if (\n    normalizedIntendedOwner &&\n    ethers.isAddress(normalizedIntendedOwner) &&\n    normalizedIntendedOwner !== signerAddress\n  ) {\n    let transferError = null;\n    try {\n      const iface = new Interface([\n        \"function transferProperty(string hash, address newOwner)\",\n      ]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [\n        normalizedHash,\n        normalizedIntendedOwner,\n      ]);\n      const tx = await signer.sendTransaction({ to: contractAddress, data });\n      await tx.wait();\n      return { registrationTxHash, transferTxHash: tx.hash };\n    } catch (error) {\n      transferError = error;\n    }\n\n    // eVault fallback: transferProperty(uint256,address)\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash, signerAddress);\n      if (property?.id) {\n        const iface = new Interface([\n          \"function transferProperty(uint256 propertyId, address newOwner)\",\n        ]);\n        const data = iface.encodeFunctionData(\"transferProperty\", [\n          property.id,\n          normalizedIntendedOwner,\n        ]);\n        const tx = await signer.sendTransaction({ to: contractAddress, data });\n        await tx.wait();\n        return { registrationTxHash, transferTxHash: tx.hash };\n      }\n    } catch (fallbackError) {\n      transferError = fallbackError;\n    }\n\n    throw new Error(\n      `Hash pushed, but owner transfer to intended wallet failed: ${String(\n        transferError?.reason ||\n          transferError?.shortMessage ||\n          transferError?.message ||\n          \"unknown error\"\n      )}`\n    );\n  }\n\n  return { registrationTxHash, transferTxHash: \"\" };\n}\n\nexport async function approvePropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`\n    );\n  }\n\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    try {\n      return await contract.documentOwner(hash);\n    } catch {\n      const property = await findEVaultPropertyByHash(hash);\n      return property?.owner || \"0x0000000000000000000000000000000000000000\";\n    }\n  }\n}\n\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n  } catch (error) {\n    // Fallback for eVault contract that uses transferProperty(uint256,address).\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash, signerAddress);\n      if (!property?.id) {\n        throw new Error(\"Property hash not found in eVault contract.\");\n      }\n      const iface = new Interface([\n        \"function transferProperty(uint256 propertyId, address newOwner)\",\n      ]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [\n        property.id,\n        normalizedOwner,\n      ]);\n      const tx = await contract.runner.sendTransaction({\n        to: contract.target,\n        data,\n      });\n      await tx.wait();\n      return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n    } catch (fallbackError) {\n      const fallbackMessage = String(\n        fallbackError?.reason ||\n          fallbackError?.shortMessage ||\n          fallbackError?.message ||\n          \"\"\n      );\n      if (fallbackMessage.includes(\"Only current owner\")) {\n        throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n      }\n      if (fallbackMessage.includes(\"Invalid owner\") || fallbackMessage.includes(\"Invalid new owner\")) {\n        throw new Error(\"Invalid recipient wallet address.\");\n      }\n      if (fallbackMessage.includes(\"Property hash not found in eVault contract\")) {\n        throw new Error(\"Property hash was not found on-chain.\");\n      }\n    }\n\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\n        \"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\"\n      );\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    if (\n      message.includes(\"CALL_EXCEPTION\") ||\n      message.includes(\"execution reverted\") ||\n      message.includes(\"require(false)\")\n    ) {\n      throw new Error(\"Transfer failed due to contract function mismatch or missing on-chain property.\");\n    }\n    throw error;\n  }\n}\n\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map((r) => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp),\n  }));\n}\n\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\n\nexport async function getWalletRoleOnChain() {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([\n    contract.registrars(signerAddress),\n    contract.admin(),\n  ]);\n\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase(),\n  };\n}\n\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const { contract } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n\n  const { contract } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data,\n  });\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\n\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\n\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}