{"ast":null,"code":"import { Interface } from \"ethers\";\nimport { ensureContractCode, ensureCorrectNetwork, ensureWalletConnected, getBrowserProvider, getContractRuntimeConfig, getReadOnlyContract, getWriteContract } from \"./eth.js\";\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return {\n    contract,\n    signerAddress\n  };\n}\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\nexport async function registerPropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`);\n  }\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\nexport async function pushHashOnChainWithWallet(hash) {\n  var _lastError, _lastError2, _lastError3;\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const {\n    contractAddress\n  } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  const attempts = [\"function requestRegistration(string ipfsHash)\", \"function registerProperty(string hash)\", \"function storeHash(string _hash)\"];\n  let lastError = null;\n  for (const fragment of attempts) {\n    try {\n      var _fragment$match;\n      const iface = new Interface([fragment]);\n      const fn = String(((_fragment$match = fragment.match(/function\\s+([^(]+)/)) === null || _fragment$match === void 0 ? void 0 : _fragment$match[1]) || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({\n        to: contractAddress,\n        data\n      });\n      await tx.wait();\n      return tx.hash;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n  throw new Error(`Wallet chain push failed: ${String(((_lastError = lastError) === null || _lastError === void 0 ? void 0 : _lastError.reason) || ((_lastError2 = lastError) === null || _lastError2 === void 0 ? void 0 : _lastError2.shortMessage) || ((_lastError3 = lastError) === null || _lastError3 === void 0 ? void 0 : _lastError3.message) || \"unknown error\")}`);\n}\nexport async function approvePropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`);\n  }\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    return await contract.documentOwner(hash);\n  }\n}\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return {\n      txHash: tx.hash,\n      from: signerAddress,\n      to: normalizedOwner\n    };\n  } catch (error) {\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\");\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    throw error;\n  }\n}\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map(r => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp)\n  }));\n}\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\nexport async function getWalletRoleOnChain() {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([contract.registrars(signerAddress), contract.admin()]);\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase()\n  };\n}\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data\n  });\n  await tx.wait();\n  return tx.hash;\n}\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}","map":{"version":3,"names":["Interface","ensureContractCode","ensureCorrectNetwork","ensureWalletConnected","getBrowserProvider","getContractRuntimeConfig","getReadOnlyContract","getWriteContract","getWriteReadyContract","provider","signer","getSigner","contract","signerAddress","getAddress","getReadReadyContract","registerPropertyOnChain","hash","isRegistrar","registrars","Error","exists","verifyHash","tx","registerProperty","wait","error","message","String","reason","shortMessage","toLowerCase","includes","storeHash","pushHashOnChainWithWallet","_lastError","_lastError2","_lastError3","contractAddress","normalizedHash","trim","attempts","lastError","fragment","_fragment$match","iface","fn","match","data","encodeFunctionData","sendTransaction","to","approvePropertyOnChain","approveProperty","verifyPropertyOnChain","verifyProperty","propertyExistsOnChain","owner","getOwner","getPropertyOwnerOnChain","documentOwner","transferPropertyOnChain","newOwner","normalizedOwner","transferProperty","txHash","from","getPropertyHistoryOnChain","records","getPropertyHistory","map","r","timestamp","Number","getAllPropertiesOnChain","getAllProperties","getWalletRoleOnChain","adminAddress","Promise","all","admin","wallet","Boolean","isAdmin","grantRegistrarOnChain","registrarAddress","addRegistrar","revokeRegistrarOnChain","normalized","runner","target","isWalletRegistrarOnChain","walletAddress","getAdminAddressOnChain","getRegistrarStatusOnChain"],"sources":["C:/Users/ahmad/OneDrive/Desktop/evault/frontend/src/contract/propertyActions.js"],"sourcesContent":["import { Interface } from \"ethers\";\nimport {\n  ensureContractCode,\n  ensureCorrectNetwork,\n  ensureWalletConnected,\n  getBrowserProvider,\n  getContractRuntimeConfig,\n  getReadOnlyContract,\n  getWriteContract,\n} from \"./eth.js\";\n\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return { contract, signerAddress };\n}\n\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\n\nexport async function registerPropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`\n    );\n  }\n\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\n\nexport async function pushHashOnChainWithWallet(hash) {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const { contractAddress } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n\n  const attempts = [\n    \"function requestRegistration(string ipfsHash)\",\n    \"function registerProperty(string hash)\",\n    \"function storeHash(string _hash)\",\n  ];\n\n  let lastError = null;\n  for (const fragment of attempts) {\n    try {\n      const iface = new Interface([fragment]);\n      const fn = String(fragment.match(/function\\s+([^(]+)/)?.[1] || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({ to: contractAddress, data });\n      await tx.wait();\n      return tx.hash;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n\n  throw new Error(\n    `Wallet chain push failed: ${String(\n      lastError?.reason || lastError?.shortMessage || lastError?.message || \"unknown error\"\n    )}`\n  );\n}\n\nexport async function approvePropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`\n    );\n  }\n\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    return await contract.documentOwner(hash);\n  }\n}\n\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\n        \"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\"\n      );\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    throw error;\n  }\n}\n\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map((r) => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp),\n  }));\n}\n\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\n\nexport async function getWalletRoleOnChain() {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([\n    contract.registrars(signerAddress),\n    contract.admin(),\n  ]);\n\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase(),\n  };\n}\n\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const { contract } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n\n  const { contract } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data,\n  });\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\n\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\n\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}