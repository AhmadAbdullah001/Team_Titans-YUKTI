{"ast":null,"code":"import { Interface } from \"ethers\";\nimport { ethers } from \"ethers\";\nimport { ensureContractCode, ensureCorrectNetwork, ensureWalletConnected, getBrowserProvider, getContractRuntimeConfig, getReadOnlyContract, getWriteContract } from \"./eth.js\";\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return {\n    contract,\n    signerAddress\n  };\n}\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\nasync function findEVaultPropertyByHash(hash) {\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) return null;\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const {\n    contractAddress\n  } = getContractRuntimeConfig();\n  const evaultReader = new ethers.Contract(contractAddress, [\"function propertyCounter() view returns (uint256)\", \"function properties(uint256) view returns (uint256 id,address owner,string ipfsHash,bool registrarApproved,bool notaryApproved,bool authorityApproved,uint256 approvalCount,uint8 status,bool bankVerified)\"], provider);\n  let count = 0;\n  try {\n    count = Number(await evaultReader.propertyCounter());\n  } catch {\n    return null;\n  }\n  for (let i = 1; i <= count; i += 1) {\n    try {\n      const row = await evaultReader.properties(i);\n      const rowHash = String((row === null || row === void 0 ? void 0 : row.ipfsHash) || \"\").trim();\n      if (rowHash && rowHash === normalizedHash) {\n        return {\n          id: Number(row.id || i),\n          owner: String(row.owner || \"\"),\n          ipfsHash: rowHash,\n          status: Number(row.status || 0),\n          approvalCount: Number(row.approvalCount || 0)\n        };\n      }\n    } catch {\n      // continue scan\n    }\n  }\n  return null;\n}\nexport async function registerPropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`);\n  }\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\nexport async function pushHashOnChainWithWallet(hash) {\n  var _lastError, _lastError2, _lastError3;\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const {\n    contractAddress\n  } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  const attempts = [\"function requestRegistration(string ipfsHash)\", \"function registerProperty(string hash)\", \"function storeHash(string _hash)\"];\n  let lastError = null;\n  for (const fragment of attempts) {\n    try {\n      var _fragment$match;\n      const iface = new Interface([fragment]);\n      const fn = String(((_fragment$match = fragment.match(/function\\s+([^(]+)/)) === null || _fragment$match === void 0 ? void 0 : _fragment$match[1]) || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({\n        to: contractAddress,\n        data\n      });\n      await tx.wait();\n      return tx.hash;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n  throw new Error(`Wallet chain push failed: ${String(((_lastError = lastError) === null || _lastError === void 0 ? void 0 : _lastError.reason) || ((_lastError2 = lastError) === null || _lastError2 === void 0 ? void 0 : _lastError2.shortMessage) || ((_lastError3 = lastError) === null || _lastError3 === void 0 ? void 0 : _lastError3.message) || \"unknown error\")}`);\n}\nexport async function approvePropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`);\n  }\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    try {\n      return await contract.documentOwner(hash);\n    } catch {\n      const property = await findEVaultPropertyByHash(hash);\n      return (property === null || property === void 0 ? void 0 : property.owner) || \"0x0000000000000000000000000000000000000000\";\n    }\n  }\n}\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return {\n      txHash: tx.hash,\n      from: signerAddress,\n      to: normalizedOwner\n    };\n  } catch (error) {\n    // Fallback for eVault contract that uses transferProperty(uint256,address).\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash);\n      if (!(property !== null && property !== void 0 && property.id)) {\n        throw new Error(\"Property hash not found in eVault contract.\");\n      }\n      const iface = new Interface([\"function transferProperty(uint256 propertyId, address newOwner)\"]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [property.id, normalizedOwner]);\n      const tx = await contract.runner.sendTransaction({\n        to: contract.target,\n        data\n      });\n      await tx.wait();\n      return {\n        txHash: tx.hash,\n        from: signerAddress,\n        to: normalizedOwner\n      };\n    } catch (fallbackError) {\n      const fallbackMessage = String((fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.reason) || (fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.shortMessage) || (fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.message) || \"\");\n      if (fallbackMessage.includes(\"Only current owner\")) {\n        throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n      }\n      if (fallbackMessage.includes(\"Invalid owner\") || fallbackMessage.includes(\"Invalid new owner\")) {\n        throw new Error(\"Invalid recipient wallet address.\");\n      }\n      if (fallbackMessage.includes(\"Property hash not found in eVault contract\")) {\n        throw new Error(\"Property hash was not found on-chain.\");\n      }\n    }\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\");\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    if (message.includes(\"CALL_EXCEPTION\") || message.includes(\"execution reverted\") || message.includes(\"require(false)\")) {\n      throw new Error(\"Transfer failed due to contract function mismatch or missing on-chain property.\");\n    }\n    throw error;\n  }\n}\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map(r => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp)\n  }));\n}\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\nexport async function getWalletRoleOnChain() {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([contract.registrars(signerAddress), contract.admin()]);\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase()\n  };\n}\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data\n  });\n  await tx.wait();\n  return tx.hash;\n}\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}","map":{"version":3,"names":["Interface","ethers","ensureContractCode","ensureCorrectNetwork","ensureWalletConnected","getBrowserProvider","getContractRuntimeConfig","getReadOnlyContract","getWriteContract","getWriteReadyContract","provider","signer","getSigner","contract","signerAddress","getAddress","getReadReadyContract","findEVaultPropertyByHash","hash","normalizedHash","String","trim","contractAddress","evaultReader","Contract","count","Number","propertyCounter","i","row","properties","rowHash","ipfsHash","id","owner","status","approvalCount","registerPropertyOnChain","isRegistrar","registrars","Error","exists","verifyHash","tx","registerProperty","wait","error","message","reason","shortMessage","toLowerCase","includes","storeHash","pushHashOnChainWithWallet","_lastError","_lastError2","_lastError3","attempts","lastError","fragment","_fragment$match","iface","fn","match","data","encodeFunctionData","sendTransaction","to","approvePropertyOnChain","approveProperty","verifyPropertyOnChain","verifyProperty","propertyExistsOnChain","getOwner","getPropertyOwnerOnChain","documentOwner","property","transferPropertyOnChain","newOwner","normalizedOwner","transferProperty","txHash","from","runner","target","fallbackError","fallbackMessage","getPropertyHistoryOnChain","records","getPropertyHistory","map","r","timestamp","getAllPropertiesOnChain","getAllProperties","getWalletRoleOnChain","adminAddress","Promise","all","admin","wallet","Boolean","isAdmin","grantRegistrarOnChain","registrarAddress","addRegistrar","revokeRegistrarOnChain","normalized","isWalletRegistrarOnChain","walletAddress","getAdminAddressOnChain","getRegistrarStatusOnChain"],"sources":["C:/Users/ahmad/OneDrive/Desktop/evault/frontend/src/contract/propertyActions.js"],"sourcesContent":["import { Interface } from \"ethers\";\nimport { ethers } from \"ethers\";\nimport {\n  ensureContractCode,\n  ensureCorrectNetwork,\n  ensureWalletConnected,\n  getBrowserProvider,\n  getContractRuntimeConfig,\n  getReadOnlyContract,\n  getWriteContract,\n} from \"./eth.js\";\n\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return { contract, signerAddress };\n}\n\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\n\nasync function findEVaultPropertyByHash(hash) {\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) return null;\n\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const { contractAddress } = getContractRuntimeConfig();\n\n  const evaultReader = new ethers.Contract(\n    contractAddress,\n    [\n      \"function propertyCounter() view returns (uint256)\",\n      \"function properties(uint256) view returns (uint256 id,address owner,string ipfsHash,bool registrarApproved,bool notaryApproved,bool authorityApproved,uint256 approvalCount,uint8 status,bool bankVerified)\",\n    ],\n    provider\n  );\n\n  let count = 0;\n  try {\n    count = Number(await evaultReader.propertyCounter());\n  } catch {\n    return null;\n  }\n\n  for (let i = 1; i <= count; i += 1) {\n    try {\n      const row = await evaultReader.properties(i);\n      const rowHash = String(row?.ipfsHash || \"\").trim();\n      if (rowHash && rowHash === normalizedHash) {\n        return {\n          id: Number(row.id || i),\n          owner: String(row.owner || \"\"),\n          ipfsHash: rowHash,\n          status: Number(row.status || 0),\n          approvalCount: Number(row.approvalCount || 0),\n        };\n      }\n    } catch {\n      // continue scan\n    }\n  }\n\n  return null;\n}\n\nexport async function registerPropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`\n    );\n  }\n\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\n\nexport async function pushHashOnChainWithWallet(hash) {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const { contractAddress } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n\n  const attempts = [\n    \"function requestRegistration(string ipfsHash)\",\n    \"function registerProperty(string hash)\",\n    \"function storeHash(string _hash)\",\n  ];\n\n  let lastError = null;\n  for (const fragment of attempts) {\n    try {\n      const iface = new Interface([fragment]);\n      const fn = String(fragment.match(/function\\s+([^(]+)/)?.[1] || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({ to: contractAddress, data });\n      await tx.wait();\n      return tx.hash;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n\n  throw new Error(\n    `Wallet chain push failed: ${String(\n      lastError?.reason || lastError?.shortMessage || lastError?.message || \"unknown error\"\n    )}`\n  );\n}\n\nexport async function approvePropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`\n    );\n  }\n\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    try {\n      return await contract.documentOwner(hash);\n    } catch {\n      const property = await findEVaultPropertyByHash(hash);\n      return property?.owner || \"0x0000000000000000000000000000000000000000\";\n    }\n  }\n}\n\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n  } catch (error) {\n    // Fallback for eVault contract that uses transferProperty(uint256,address).\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash);\n      if (!property?.id) {\n        throw new Error(\"Property hash not found in eVault contract.\");\n      }\n      const iface = new Interface([\n        \"function transferProperty(uint256 propertyId, address newOwner)\",\n      ]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [\n        property.id,\n        normalizedOwner,\n      ]);\n      const tx = await contract.runner.sendTransaction({\n        to: contract.target,\n        data,\n      });\n      await tx.wait();\n      return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n    } catch (fallbackError) {\n      const fallbackMessage = String(\n        fallbackError?.reason ||\n          fallbackError?.shortMessage ||\n          fallbackError?.message ||\n          \"\"\n      );\n      if (fallbackMessage.includes(\"Only current owner\")) {\n        throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n      }\n      if (fallbackMessage.includes(\"Invalid owner\") || fallbackMessage.includes(\"Invalid new owner\")) {\n        throw new Error(\"Invalid recipient wallet address.\");\n      }\n      if (fallbackMessage.includes(\"Property hash not found in eVault contract\")) {\n        throw new Error(\"Property hash was not found on-chain.\");\n      }\n    }\n\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\n        \"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\"\n      );\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    if (\n      message.includes(\"CALL_EXCEPTION\") ||\n      message.includes(\"execution reverted\") ||\n      message.includes(\"require(false)\")\n    ) {\n      throw new Error(\"Transfer failed due to contract function mismatch or missing on-chain property.\");\n    }\n    throw error;\n  }\n}\n\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map((r) => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp),\n  }));\n}\n\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\n\nexport async function getWalletRoleOnChain() {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([\n    contract.registrars(signerAddress),\n    contract.admin(),\n  ]);\n\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase(),\n  };\n}\n\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const { contract } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n\n  const { contract } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data,\n  });\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\n\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\n\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,QAAQ;AAClC,SAASC,MAAM,QAAQ,QAAQ;AAC/B,SACEC,kBAAkB,EAClBC,oBAAoB,EACpBC,qBAAqB,EACrBC,kBAAkB,EAClBC,wBAAwB,EACxBC,mBAAmB,EACnBC,gBAAgB,QACX,UAAU;AAEjB,eAAeC,qBAAqBA,CAAA,EAAG;EACrC,MAAMC,QAAQ,GAAG,MAAML,kBAAkB,CAAC,CAAC;EAC3C,MAAMD,qBAAqB,CAACM,QAAQ,CAAC;EACrC,MAAMP,oBAAoB,CAACO,QAAQ,CAAC;EACpC,MAAMR,kBAAkB,CAACQ,QAAQ,CAAC;EAClC,MAAMC,MAAM,GAAG,MAAMD,QAAQ,CAACE,SAAS,CAAC,CAAC;EACzC,MAAMC,QAAQ,GAAGL,gBAAgB,CAACG,MAAM,CAAC;EACzC,MAAMG,aAAa,GAAG,MAAMH,MAAM,CAACI,UAAU,CAAC,CAAC;EAC/C,OAAO;IAAEF,QAAQ;IAAEC;EAAc,CAAC;AACpC;AAEA,eAAeE,oBAAoBA,CAAA,EAAG;EACpC,MAAMN,QAAQ,GAAG,MAAML,kBAAkB,CAAC,CAAC;EAC3C,MAAMD,qBAAqB,CAACM,QAAQ,CAAC;EACrC,MAAMP,oBAAoB,CAACO,QAAQ,CAAC;EACpC,MAAMR,kBAAkB,CAACQ,QAAQ,CAAC;EAClC,OAAOH,mBAAmB,CAACG,QAAQ,CAAC;AACtC;AAEA,eAAeO,wBAAwBA,CAACC,IAAI,EAAE;EAC5C,MAAMC,cAAc,GAAGC,MAAM,CAACF,IAAI,IAAI,EAAE,CAAC,CAACG,IAAI,CAAC,CAAC;EAChD,IAAI,CAACF,cAAc,EAAE,OAAO,IAAI;EAEhC,MAAMT,QAAQ,GAAG,MAAML,kBAAkB,CAAC,CAAC;EAC3C,MAAMD,qBAAqB,CAACM,QAAQ,CAAC;EACrC,MAAMP,oBAAoB,CAACO,QAAQ,CAAC;EACpC,MAAMR,kBAAkB,CAACQ,QAAQ,CAAC;EAClC,MAAM;IAAEY;EAAgB,CAAC,GAAGhB,wBAAwB,CAAC,CAAC;EAEtD,MAAMiB,YAAY,GAAG,IAAItB,MAAM,CAACuB,QAAQ,CACtCF,eAAe,EACf,CACE,mDAAmD,EACnD,6MAA6M,CAC9M,EACDZ,QACF,CAAC;EAED,IAAIe,KAAK,GAAG,CAAC;EACb,IAAI;IACFA,KAAK,GAAGC,MAAM,CAAC,MAAMH,YAAY,CAACI,eAAe,CAAC,CAAC,CAAC;EACtD,CAAC,CAAC,MAAM;IACN,OAAO,IAAI;EACb;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIH,KAAK,EAAEG,CAAC,IAAI,CAAC,EAAE;IAClC,IAAI;MACF,MAAMC,GAAG,GAAG,MAAMN,YAAY,CAACO,UAAU,CAACF,CAAC,CAAC;MAC5C,MAAMG,OAAO,GAAGX,MAAM,CAAC,CAAAS,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEG,QAAQ,KAAI,EAAE,CAAC,CAACX,IAAI,CAAC,CAAC;MAClD,IAAIU,OAAO,IAAIA,OAAO,KAAKZ,cAAc,EAAE;QACzC,OAAO;UACLc,EAAE,EAAEP,MAAM,CAACG,GAAG,CAACI,EAAE,IAAIL,CAAC,CAAC;UACvBM,KAAK,EAAEd,MAAM,CAACS,GAAG,CAACK,KAAK,IAAI,EAAE,CAAC;UAC9BF,QAAQ,EAAED,OAAO;UACjBI,MAAM,EAAET,MAAM,CAACG,GAAG,CAACM,MAAM,IAAI,CAAC,CAAC;UAC/BC,aAAa,EAAEV,MAAM,CAACG,GAAG,CAACO,aAAa,IAAI,CAAC;QAC9C,CAAC;MACH;IACF,CAAC,CAAC,MAAM;MACN;IAAA;EAEJ;EAEA,OAAO,IAAI;AACb;AAEA,OAAO,eAAeC,uBAAuBA,CAACnB,IAAI,EAAE;EAClD,MAAM;IAAEL,QAAQ;IAAEC;EAAc,CAAC,GAAG,MAAML,qBAAqB,CAAC,CAAC;EAEjE,MAAM6B,WAAW,GAAG,MAAMzB,QAAQ,CAAC0B,UAAU,CAACzB,aAAa,CAAC;EAC5D,IAAIwB,WAAW,EAAE;IACf,MAAM,IAAIE,KAAK,CACb,oBAAoB1B,aAAa,8FACnC,CAAC;EACH;EAEA,IAAI;IACF,MAAM2B,MAAM,GAAG,MAAM5B,QAAQ,CAAC6B,UAAU,CAACxB,IAAI,CAAC;IAC9C,IAAIuB,MAAM,EAAE;MACV,OAAO,oBAAoB;IAC7B;EACF,CAAC,CAAC,MAAM;IACN;EAAA;EAGF,IAAI;IACF,MAAME,EAAE,GAAG,MAAM9B,QAAQ,CAAC+B,gBAAgB,CAAC1B,IAAI,CAAC;IAChD,MAAMyB,EAAE,CAACE,IAAI,CAAC,CAAC;IACf,OAAOF,EAAE,CAACzB,IAAI;EAChB,CAAC,CAAC,OAAO4B,KAAK,EAAE;IACd,MAAMC,OAAO,GAAG3B,MAAM,CAAC,CAAA0B,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEE,MAAM,MAAIF,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEG,YAAY,MAAIH,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,OAAO,KAAI,EAAE,CAAC;IACpF,IAAIA,OAAO,CAACG,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,gBAAgB,CAAC,EAAE;MACpD,OAAO,oBAAoB;IAC7B;IACA,IAAIJ,OAAO,CAACI,QAAQ,CAAC,mBAAmB,CAAC,IAAIJ,OAAO,CAACI,QAAQ,CAAC,qBAAqB,CAAC,EAAE;MACpF,MAAMR,EAAE,GAAG,MAAM9B,QAAQ,CAACuC,SAAS,CAAClC,IAAI,CAAC;MACzC,MAAMyB,EAAE,CAACE,IAAI,CAAC,CAAC;MACf,OAAOF,EAAE,CAACzB,IAAI;IAChB;IACA,MAAM4B,KAAK;EACb;AACF;AAEA,OAAO,eAAeO,yBAAyBA,CAACnC,IAAI,EAAE;EAAA,IAAAoC,UAAA,EAAAC,WAAA,EAAAC,WAAA;EACpD,MAAM9C,QAAQ,GAAG,MAAML,kBAAkB,CAAC,CAAC;EAC3C,MAAMD,qBAAqB,CAACM,QAAQ,CAAC;EACrC,MAAMP,oBAAoB,CAACO,QAAQ,CAAC;EACpC,MAAMR,kBAAkB,CAACQ,QAAQ,CAAC;EAClC,MAAMC,MAAM,GAAG,MAAMD,QAAQ,CAACE,SAAS,CAAC,CAAC;EACzC,MAAM;IAAEU;EAAgB,CAAC,GAAGhB,wBAAwB,CAAC,CAAC;EACtD,MAAMa,cAAc,GAAGC,MAAM,CAACF,IAAI,IAAI,EAAE,CAAC,CAACG,IAAI,CAAC,CAAC;EAChD,IAAI,CAACF,cAAc,EAAE;IACnB,MAAM,IAAIqB,KAAK,CAAC,2BAA2B,CAAC;EAC9C;EAEA,MAAMiB,QAAQ,GAAG,CACf,+CAA+C,EAC/C,wCAAwC,EACxC,kCAAkC,CACnC;EAED,IAAIC,SAAS,GAAG,IAAI;EACpB,KAAK,MAAMC,QAAQ,IAAIF,QAAQ,EAAE;IAC/B,IAAI;MAAA,IAAAG,eAAA;MACF,MAAMC,KAAK,GAAG,IAAI7D,SAAS,CAAC,CAAC2D,QAAQ,CAAC,CAAC;MACvC,MAAMG,EAAE,GAAG1C,MAAM,CAAC,EAAAwC,eAAA,GAAAD,QAAQ,CAACI,KAAK,CAAC,oBAAoB,CAAC,cAAAH,eAAA,uBAApCA,eAAA,CAAuC,CAAC,CAAC,KAAI,EAAE,CAAC,CAACvC,IAAI,CAAC,CAAC;MACzE,MAAM2C,IAAI,GAAGH,KAAK,CAACI,kBAAkB,CAACH,EAAE,EAAE,CAAC3C,cAAc,CAAC,CAAC;MAC3D,MAAMwB,EAAE,GAAG,MAAMhC,MAAM,CAACuD,eAAe,CAAC;QAAEC,EAAE,EAAE7C,eAAe;QAAE0C;MAAK,CAAC,CAAC;MACtE,MAAMrB,EAAE,CAACE,IAAI,CAAC,CAAC;MACf,OAAOF,EAAE,CAACzB,IAAI;IAChB,CAAC,CAAC,OAAO4B,KAAK,EAAE;MACdY,SAAS,GAAGZ,KAAK;IACnB;EACF;EAEA,MAAM,IAAIN,KAAK,CACb,6BAA6BpB,MAAM,CACjC,EAAAkC,UAAA,GAAAI,SAAS,cAAAJ,UAAA,uBAATA,UAAA,CAAWN,MAAM,OAAAO,WAAA,GAAIG,SAAS,cAAAH,WAAA,uBAATA,WAAA,CAAWN,YAAY,OAAAO,WAAA,GAAIE,SAAS,cAAAF,WAAA,uBAATA,WAAA,CAAWT,OAAO,KAAI,eACxE,CAAC,EACH,CAAC;AACH;AAEA,OAAO,eAAeqB,sBAAsBA,CAAClD,IAAI,EAAE;EACjD,MAAM;IAAEL,QAAQ;IAAEC;EAAc,CAAC,GAAG,MAAML,qBAAqB,CAAC,CAAC;EAEjE,MAAM6B,WAAW,GAAG,MAAMzB,QAAQ,CAAC0B,UAAU,CAACzB,aAAa,CAAC;EAC5D,IAAI,CAACwB,WAAW,EAAE;IAChB,MAAM,IAAIE,KAAK,CACb,oBAAoB1B,aAAa,6DACnC,CAAC;EACH;EAEA,MAAM6B,EAAE,GAAG,MAAM9B,QAAQ,CAACwD,eAAe,CAACnD,IAAI,CAAC;EAC/C,MAAMyB,EAAE,CAACE,IAAI,CAAC,CAAC;EACf,OAAOF,EAAE,CAACzB,IAAI;AAChB;AAEA,OAAO,eAAeoD,qBAAqBA,CAACpD,IAAI,EAAE;EAChD,MAAML,QAAQ,GAAG,MAAMG,oBAAoB,CAAC,CAAC;EAC7C,IAAI;IACF,OAAO,MAAMH,QAAQ,CAAC0D,cAAc,CAACrD,IAAI,CAAC;EAC5C,CAAC,CAAC,MAAM;IACN,IAAI;MACF,OAAO,MAAML,QAAQ,CAAC6B,UAAU,CAACxB,IAAI,CAAC;IACxC,CAAC,CAAC,MAAM;MACN,OAAO,KAAK;IACd;EACF;AACF;AAEA,OAAO,eAAesD,qBAAqBA,CAACtD,IAAI,EAAE;EAChD,MAAML,QAAQ,GAAG,MAAMG,oBAAoB,CAAC,CAAC;EAC7C,IAAI;IACF,OAAO,MAAMH,QAAQ,CAAC6B,UAAU,CAACxB,IAAI,CAAC;EACxC,CAAC,CAAC,MAAM;IACN,IAAI;MACF,MAAMgB,KAAK,GAAG,MAAMrB,QAAQ,CAAC4D,QAAQ,CAACvD,IAAI,CAAC;MAC3C,OAAOgB,KAAK,IAAIA,KAAK,KAAK,4CAA4C;IACxE,CAAC,CAAC,MAAM;MACN,OAAO,IAAI;IACb;EACF;AACF;AAEA,OAAO,eAAewC,uBAAuBA,CAACxD,IAAI,EAAE;EAClD,MAAML,QAAQ,GAAG,MAAMG,oBAAoB,CAAC,CAAC;EAC7C,IAAI;IACF,OAAO,MAAMH,QAAQ,CAAC4D,QAAQ,CAACvD,IAAI,CAAC;EACtC,CAAC,CAAC,MAAM;IACN,IAAI;MACF,OAAO,MAAML,QAAQ,CAAC8D,aAAa,CAACzD,IAAI,CAAC;IAC3C,CAAC,CAAC,MAAM;MACN,MAAM0D,QAAQ,GAAG,MAAM3D,wBAAwB,CAACC,IAAI,CAAC;MACrD,OAAO,CAAA0D,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAE1C,KAAK,KAAI,4CAA4C;IACxE;EACF;AACF;AAEA,OAAO,eAAe2C,uBAAuBA,CAAC3D,IAAI,EAAE4D,QAAQ,EAAE;EAC5D,MAAM;IAAEjE,QAAQ;IAAEC;EAAc,CAAC,GAAG,MAAML,qBAAqB,CAAC,CAAC;EACjE,MAAMU,cAAc,GAAGC,MAAM,CAACF,IAAI,IAAI,EAAE,CAAC,CAACG,IAAI,CAAC,CAAC;EAChD,MAAM0D,eAAe,GAAG3D,MAAM,CAAC0D,QAAQ,IAAI,EAAE,CAAC,CAACzD,IAAI,CAAC,CAAC;EAErD,IAAI,CAACF,cAAc,EAAE;IACnB,MAAM,IAAIqB,KAAK,CAAC,2BAA2B,CAAC;EAC9C;EACA,IAAI,CAACuC,eAAe,EAAE;IACpB,MAAM,IAAIvC,KAAK,CAAC,sCAAsC,CAAC;EACzD;EAEA,IAAI;IACF,MAAMG,EAAE,GAAG,MAAM9B,QAAQ,CAACmE,gBAAgB,CAAC7D,cAAc,EAAE4D,eAAe,CAAC;IAC3E,MAAMpC,EAAE,CAACE,IAAI,CAAC,CAAC;IACf,OAAO;MAAEoC,MAAM,EAAEtC,EAAE,CAACzB,IAAI;MAAEgE,IAAI,EAAEpE,aAAa;MAAEqD,EAAE,EAAEY;IAAgB,CAAC;EACtE,CAAC,CAAC,OAAOjC,KAAK,EAAE;IACd;IACA,IAAI;MACF,MAAM8B,QAAQ,GAAG,MAAM3D,wBAAwB,CAACE,cAAc,CAAC;MAC/D,IAAI,EAACyD,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAE3C,EAAE,GAAE;QACjB,MAAM,IAAIO,KAAK,CAAC,6CAA6C,CAAC;MAChE;MACA,MAAMqB,KAAK,GAAG,IAAI7D,SAAS,CAAC,CAC1B,iEAAiE,CAClE,CAAC;MACF,MAAMgE,IAAI,GAAGH,KAAK,CAACI,kBAAkB,CAAC,kBAAkB,EAAE,CACxDW,QAAQ,CAAC3C,EAAE,EACX8C,eAAe,CAChB,CAAC;MACF,MAAMpC,EAAE,GAAG,MAAM9B,QAAQ,CAACsE,MAAM,CAACjB,eAAe,CAAC;QAC/CC,EAAE,EAAEtD,QAAQ,CAACuE,MAAM;QACnBpB;MACF,CAAC,CAAC;MACF,MAAMrB,EAAE,CAACE,IAAI,CAAC,CAAC;MACf,OAAO;QAAEoC,MAAM,EAAEtC,EAAE,CAACzB,IAAI;QAAEgE,IAAI,EAAEpE,aAAa;QAAEqD,EAAE,EAAEY;MAAgB,CAAC;IACtE,CAAC,CAAC,OAAOM,aAAa,EAAE;MACtB,MAAMC,eAAe,GAAGlE,MAAM,CAC5B,CAAAiE,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAErC,MAAM,MACnBqC,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEpC,YAAY,MAC3BoC,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEtC,OAAO,KACtB,EACJ,CAAC;MACD,IAAIuC,eAAe,CAACnC,QAAQ,CAAC,oBAAoB,CAAC,EAAE;QAClD,MAAM,IAAIX,KAAK,CAAC,sEAAsE,CAAC;MACzF;MACA,IAAI8C,eAAe,CAACnC,QAAQ,CAAC,eAAe,CAAC,IAAImC,eAAe,CAACnC,QAAQ,CAAC,mBAAmB,CAAC,EAAE;QAC9F,MAAM,IAAIX,KAAK,CAAC,mCAAmC,CAAC;MACtD;MACA,IAAI8C,eAAe,CAACnC,QAAQ,CAAC,4CAA4C,CAAC,EAAE;QAC1E,MAAM,IAAIX,KAAK,CAAC,uCAAuC,CAAC;MAC1D;IACF;IAEA,MAAMO,OAAO,GAAG3B,MAAM,CAAC,CAAA0B,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEE,MAAM,MAAIF,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEG,YAAY,MAAIH,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,OAAO,KAAI,EAAE,CAAC;IACpF,IAAIA,OAAO,CAACI,QAAQ,CAAC,oBAAoB,CAAC,EAAE;MAC1C,MAAM,IAAIX,KAAK,CACb,iGACF,CAAC;IACH;IACA,IAAIO,OAAO,CAACI,QAAQ,CAAC,oBAAoB,CAAC,EAAE;MAC1C,MAAM,IAAIX,KAAK,CAAC,sEAAsE,CAAC;IACzF;IACA,IAAIO,OAAO,CAACI,QAAQ,CAAC,mBAAmB,CAAC,EAAE;MACzC,MAAM,IAAIX,KAAK,CAAC,mCAAmC,CAAC;IACtD;IACA,IAAIO,OAAO,CAACI,QAAQ,CAAC,eAAe,CAAC,EAAE;MACrC,MAAM,IAAIX,KAAK,CAAC,gDAAgD,CAAC;IACnE;IACA,IACEO,OAAO,CAACI,QAAQ,CAAC,gBAAgB,CAAC,IAClCJ,OAAO,CAACI,QAAQ,CAAC,oBAAoB,CAAC,IACtCJ,OAAO,CAACI,QAAQ,CAAC,gBAAgB,CAAC,EAClC;MACA,MAAM,IAAIX,KAAK,CAAC,iFAAiF,CAAC;IACpG;IACA,MAAMM,KAAK;EACb;AACF;AAEA,OAAO,eAAeyC,yBAAyBA,CAACrE,IAAI,EAAE;EACpD,MAAML,QAAQ,GAAG,MAAMG,oBAAoB,CAAC,CAAC;EAC7C,MAAMwE,OAAO,GAAG,MAAM3E,QAAQ,CAAC4E,kBAAkB,CAACvE,IAAI,CAAC;EACvD,OAAO,CAACsE,OAAO,IAAI,EAAE,EAAEE,GAAG,CAAEC,CAAC,KAAM;IACjCT,IAAI,EAAES,CAAC,CAACT,IAAI;IACZf,EAAE,EAAEwB,CAAC,CAACxB,EAAE;IACRyB,SAAS,EAAElE,MAAM,CAACiE,CAAC,CAACC,SAAS;EAC/B,CAAC,CAAC,CAAC;AACL;AAEA,OAAO,eAAeC,uBAAuBA,CAAA,EAAG;EAC9C,MAAMhF,QAAQ,GAAG,MAAMG,oBAAoB,CAAC,CAAC;EAC7C,OAAO,MAAMH,QAAQ,CAACiF,gBAAgB,CAAC,CAAC;AAC1C;AAEA,OAAO,eAAeC,oBAAoBA,CAAA,EAAG;EAC3C,MAAM;IAAElF,QAAQ;IAAEC;EAAc,CAAC,GAAG,MAAML,qBAAqB,CAAC,CAAC;EACjE,MAAM,CAAC6B,WAAW,EAAE0D,YAAY,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACpDrF,QAAQ,CAAC0B,UAAU,CAACzB,aAAa,CAAC,EAClCD,QAAQ,CAACsF,KAAK,CAAC,CAAC,CACjB,CAAC;EAEF,OAAO;IACLC,MAAM,EAAEtF,aAAa;IACrBwB,WAAW,EAAE+D,OAAO,CAAC/D,WAAW,CAAC;IACjC0D,YAAY;IACZM,OAAO,EAAElF,MAAM,CAAC4E,YAAY,CAAC,CAAC9C,WAAW,CAAC,CAAC,KAAK9B,MAAM,CAACN,aAAa,CAAC,CAACoC,WAAW,CAAC;EACpF,CAAC;AACH;AAEA,OAAO,eAAeqD,qBAAqBA,CAACC,gBAAgB,EAAE;EAC5D,MAAM;IAAE3F;EAAS,CAAC,GAAG,MAAMJ,qBAAqB,CAAC,CAAC;EAClD,MAAMkC,EAAE,GAAG,MAAM9B,QAAQ,CAAC4F,YAAY,CAACD,gBAAgB,CAAC;EACxD,MAAM7D,EAAE,CAACE,IAAI,CAAC,CAAC;EACf,OAAOF,EAAE,CAACzB,IAAI;AAChB;AAEA,OAAO,eAAewF,sBAAsBA,CAACF,gBAAgB,EAAE;EAC7D,MAAMG,UAAU,GAAGvF,MAAM,CAACoF,gBAAgB,IAAI,EAAE,CAAC,CAACnF,IAAI,CAAC,CAAC;EACxD,IAAI,CAACsF,UAAU,EAAE;IACf,MAAM,IAAInE,KAAK,CAAC,sCAAsC,CAAC;EACzD;EAEA,MAAM;IAAE3B;EAAS,CAAC,GAAG,MAAMJ,qBAAqB,CAAC,CAAC;EAClD,MAAMoD,KAAK,GAAG,IAAI7D,SAAS,CAAC,CAAC,6CAA6C,CAAC,CAAC;EAC5E,MAAMgE,IAAI,GAAGH,KAAK,CAACI,kBAAkB,CAAC,iBAAiB,EAAE,CAAC0C,UAAU,CAAC,CAAC;EAEtE,MAAMhE,EAAE,GAAG,MAAM9B,QAAQ,CAACsE,MAAM,CAACjB,eAAe,CAAC;IAC/CC,EAAE,EAAEtD,QAAQ,CAACuE,MAAM;IACnBpB;EACF,CAAC,CAAC;EACF,MAAMrB,EAAE,CAACE,IAAI,CAAC,CAAC;EACf,OAAOF,EAAE,CAACzB,IAAI;AAChB;AAEA,OAAO,eAAe0F,wBAAwBA,CAACC,aAAa,EAAE;EAC5D,MAAMF,UAAU,GAAGvF,MAAM,CAACyF,aAAa,IAAI,EAAE,CAAC,CAACxF,IAAI,CAAC,CAAC;EACrD,IAAI,CAACsF,UAAU,EAAE,OAAO,KAAK;EAC7B,MAAM9F,QAAQ,GAAG,MAAMG,oBAAoB,CAAC,CAAC;EAC7C,OAAOqF,OAAO,CAAC,MAAMxF,QAAQ,CAAC0B,UAAU,CAACoE,UAAU,CAAC,CAAC;AACvD;AAEA,OAAO,eAAeG,sBAAsBA,CAAA,EAAG;EAC7C,MAAMjG,QAAQ,GAAG,MAAMG,oBAAoB,CAAC,CAAC;EAC7C,OAAO,MAAMH,QAAQ,CAACsF,KAAK,CAAC,CAAC;AAC/B;AAEA,OAAO,eAAeY,yBAAyBA,CAACF,aAAa,EAAE;EAC7D,OAAO,MAAMD,wBAAwB,CAACC,aAAa,CAAC;AACtD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}