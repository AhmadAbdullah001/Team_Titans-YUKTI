{"ast":null,"code":"import{Interface}from\"ethers\";import{ethers}from\"ethers\";import{ensureContractCode,ensureCorrectNetwork,ensureWalletConnected,getBrowserProvider,getContractRuntimeConfig,getReadOnlyContract,getWriteContract}from\"./eth.js\";async function getWriteReadyContract(){const provider=await getBrowserProvider();await ensureWalletConnected(provider);await ensureCorrectNetwork(provider);await ensureContractCode(provider);const signer=await provider.getSigner();const contract=getWriteContract(signer);const signerAddress=await signer.getAddress();return{contract,signerAddress};}async function getReadReadyContract(){const provider=await getBrowserProvider();await ensureWalletConnected(provider);await ensureCorrectNetwork(provider);await ensureContractCode(provider);return getReadOnlyContract(provider);}async function findEVaultPropertiesByHash(hash){const normalizedHash=String(hash||\"\").trim();if(!normalizedHash)return[];const provider=await getBrowserProvider();await ensureWalletConnected(provider);await ensureCorrectNetwork(provider);await ensureContractCode(provider);const{contractAddress}=getContractRuntimeConfig();const evaultReader=new ethers.Contract(contractAddress,[\"function propertyCounter() view returns (uint256)\",\"function properties(uint256) view returns (uint256 id,address owner,string ipfsHash,bool registrarApproved,bool notaryApproved,bool authorityApproved,uint256 approvalCount,uint8 status,bool bankVerified)\"],provider);let count=0;try{count=Number(await evaultReader.propertyCounter());}catch(_unused){return[];}const matches=[];for(let i=1;i<=count;i+=1){try{const row=await evaultReader.properties(i);const rowHash=String((row===null||row===void 0?void 0:row.ipfsHash)||\"\").trim();if(rowHash&&rowHash===normalizedHash){matches.push({id:Number(row.id||i),owner:String(row.owner||\"\"),ipfsHash:rowHash,status:Number(row.status||0),approvalCount:Number(row.approvalCount||0)});}}catch(_unused2){// continue scan\n}}return matches;}async function findEVaultPropertyByHash(hash){let preferredOwner=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"\";const matches=await findEVaultPropertiesByHash(hash);if(!matches.length)return null;const normalizedPreferredOwner=String(preferredOwner||\"\").trim().toLowerCase();if(normalizedPreferredOwner){const owned=matches.filter(m=>String(m.owner||\"\").toLowerCase()===normalizedPreferredOwner).sort((a,b)=>b.id-a.id);if(owned.length)return owned[0];}// Prefer latest registered record; otherwise latest id.\nconst registered=matches.filter(m=>Number(m.status)===2).sort((a,b)=>b.id-a.id);if(registered.length)return registered[0];return matches.sort((a,b)=>b.id-a.id)[0];}export async function getPropertyStateOnChain(hash){let preferredOwner=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"\";const normalizedHash=String(hash||\"\").trim();const property=await findEVaultPropertyByHash(normalizedHash,preferredOwner);if(property){return property;}const contract=await getReadReadyContract();let owner=ethers.ZeroAddress;try{owner=await contract.getOwner(normalizedHash);}catch(_unused3){try{owner=await contract.documentOwner(normalizedHash);}catch(_unused4){owner=ethers.ZeroAddress;}}let verified=false;try{verified=await contract.verifyProperty(normalizedHash);}catch(_unused5){try{verified=await contract.verifyHash(normalizedHash);}catch(_unused6){verified=false;}}if(owner&&String(owner).toLowerCase()!==ethers.ZeroAddress.toLowerCase()){return{id:0,owner:String(owner),ipfsHash:normalizedHash,status:verified?2:0,approvalCount:0};}throw new Error(\"Property hash was not found on-chain.\");}export async function registerPropertyOnChain(hash){const{contract,signerAddress}=await getWriteReadyContract();const isRegistrar=await contract.registrars(signerAddress);if(isRegistrar){throw new Error(\"Connected wallet \".concat(signerAddress,\" is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.\"));}try{const exists=await contract.verifyHash(hash);if(exists){return\"already-registered\";}}catch(_unused7){// continue and try write path\n}try{const tx=await contract.registerProperty(hash);await tx.wait();return tx.hash;}catch(error){const message=String((error===null||error===void 0?void 0:error.reason)||(error===null||error===void 0?void 0:error.shortMessage)||(error===null||error===void 0?void 0:error.message)||\"\");if(message.toLowerCase().includes(\"already exists\")){return\"already-registered\";}if(message.includes(\"is not a function\")||message.includes(\"missing revert data\")){const tx=await contract.storeHash(hash);await tx.wait();return tx.hash;}throw error;}}export async function pushHashOnChainWithWallet(hash){let intendedOwner=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"\";const provider=await getBrowserProvider();await ensureWalletConnected(provider);await ensureCorrectNetwork(provider);await ensureContractCode(provider);const signer=await provider.getSigner();const signerAddress=String(await signer.getAddress()).toLowerCase();const{contractAddress}=getContractRuntimeConfig();const normalizedHash=String(hash||\"\").trim();const normalizedIntendedOwner=String(intendedOwner||\"\").trim().toLowerCase();if(!normalizedHash){throw new Error(\"Property hash is required\");}const attempts=[\"function requestRegistration(string ipfsHash)\",\"function registerProperty(string hash)\",\"function storeHash(string _hash)\"];let lastError=null;let registrationTxHash=\"\";for(const fragment of attempts){try{var _fragment$match;const iface=new Interface([fragment]);const fn=String(((_fragment$match=fragment.match(/function\\s+([^(]+)/))===null||_fragment$match===void 0?void 0:_fragment$match[1])||\"\").trim();const data=iface.encodeFunctionData(fn,[normalizedHash]);const tx=await signer.sendTransaction({to:contractAddress,data});await tx.wait();registrationTxHash=tx.hash;break;}catch(error){lastError=error;}}if(!registrationTxHash){var _lastError,_lastError2,_lastError3;throw new Error(\"Wallet chain push failed: \".concat(String(((_lastError=lastError)===null||_lastError===void 0?void 0:_lastError.reason)||((_lastError2=lastError)===null||_lastError2===void 0?void 0:_lastError2.shortMessage)||((_lastError3=lastError)===null||_lastError3===void 0?void 0:_lastError3.message)||\"unknown error\")));}// If reviewer wallet pushed the hash, transfer ownership to intended owner immediately.\nif(normalizedIntendedOwner&&ethers.isAddress(normalizedIntendedOwner)&&normalizedIntendedOwner!==signerAddress){var _transferError,_transferError2,_transferError3;let transferError=null;try{const iface=new Interface([\"function transferProperty(string hash, address newOwner)\"]);const data=iface.encodeFunctionData(\"transferProperty\",[normalizedHash,normalizedIntendedOwner]);const tx=await signer.sendTransaction({to:contractAddress,data});await tx.wait();return{registrationTxHash,transferTxHash:tx.hash};}catch(error){transferError=error;}// eVault fallback: transferProperty(uint256,address)\ntry{const property=await findEVaultPropertyByHash(normalizedHash,signerAddress);if(property!==null&&property!==void 0&&property.id){const iface=new Interface([\"function transferProperty(uint256 propertyId, address newOwner)\"]);const data=iface.encodeFunctionData(\"transferProperty\",[property.id,normalizedIntendedOwner]);const tx=await signer.sendTransaction({to:contractAddress,data});await tx.wait();return{registrationTxHash,transferTxHash:tx.hash};}}catch(fallbackError){transferError=fallbackError;}throw new Error(\"Hash pushed, but owner transfer to intended wallet failed: \".concat(String(((_transferError=transferError)===null||_transferError===void 0?void 0:_transferError.reason)||((_transferError2=transferError)===null||_transferError2===void 0?void 0:_transferError2.shortMessage)||((_transferError3=transferError)===null||_transferError3===void 0?void 0:_transferError3.message)||\"unknown error\")));}return{registrationTxHash,transferTxHash:\"\"};}export async function approvePropertyOnChain(hash){const{contract,signerAddress}=await getWriteReadyContract();const isRegistrar=await contract.registrars(signerAddress);if(!isRegistrar){throw new Error(\"Connected wallet \".concat(signerAddress,\" is not on-chain registrar. Ask admin to call addRegistrar.\"));}const tx=await contract.approveProperty(hash);await tx.wait();return tx.hash;}export async function verifyPropertyOnChain(hash){const contract=await getReadReadyContract();try{return await contract.verifyProperty(hash);}catch(_unused8){try{return await contract.verifyHash(hash);}catch(_unused9){return false;}}}export async function propertyExistsOnChain(hash){const contract=await getReadReadyContract();try{return await contract.verifyHash(hash);}catch(_unused0){try{const owner=await contract.getOwner(hash);return owner&&owner!==\"0x0000000000000000000000000000000000000000\";}catch(_unused1){return null;}}}export async function getPropertyOwnerOnChain(hash){const contract=await getReadReadyContract();try{return await contract.getOwner(hash);}catch(_unused10){try{return await contract.documentOwner(hash);}catch(_unused11){const property=await findEVaultPropertyByHash(hash);return(property===null||property===void 0?void 0:property.owner)||\"0x0000000000000000000000000000000000000000\";}}}export async function transferPropertyOnChain(hash,newOwner){const{contract,signerAddress}=await getWriteReadyContract();const normalizedHash=String(hash||\"\").trim();const normalizedOwner=String(newOwner||\"\").trim();if(!normalizedHash){throw new Error(\"Property hash is required\");}if(!normalizedOwner){throw new Error(\"New owner wallet address is required\");}try{const tx=await contract.transferProperty(normalizedHash,normalizedOwner);await tx.wait();return{txHash:tx.hash,from:signerAddress,to:normalizedOwner};}catch(error){// Fallback for eVault contract that uses transferProperty(uint256,address).\ntry{const property=await findEVaultPropertyByHash(normalizedHash,signerAddress);if(!(property!==null&&property!==void 0&&property.id)){throw new Error(\"Property hash not found in eVault contract.\");}const iface=new Interface([\"function transferProperty(uint256 propertyId, address newOwner)\"]);const data=iface.encodeFunctionData(\"transferProperty\",[property.id,normalizedOwner]);const tx=await contract.runner.sendTransaction({to:contract.target,data});await tx.wait();return{txHash:tx.hash,from:signerAddress,to:normalizedOwner};}catch(fallbackError){const fallbackMessage=String((fallbackError===null||fallbackError===void 0?void 0:fallbackError.reason)||(fallbackError===null||fallbackError===void 0?void 0:fallbackError.shortMessage)||(fallbackError===null||fallbackError===void 0?void 0:fallbackError.message)||\"\");if(fallbackMessage.includes(\"Only current owner\")){throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");}if(fallbackMessage.includes(\"Invalid owner\")||fallbackMessage.includes(\"Invalid new owner\")){throw new Error(\"Invalid recipient wallet address.\");}if(fallbackMessage.includes(\"Property hash not found in eVault contract\")){throw new Error(\"Property hash was not found on-chain.\");}}const message=String((error===null||error===void 0?void 0:error.reason)||(error===null||error===void 0?void 0:error.shortMessage)||(error===null||error===void 0?void 0:error.message)||\"\");if(message.includes(\"Property not found\")){throw new Error(\"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\");}if(message.includes(\"Only current owner\")){throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");}if(message.includes(\"Invalid new owner\")){throw new Error(\"Invalid recipient wallet address.\");}if(message.includes(\"Already owner\")){throw new Error(\"Recipient wallet is already the current owner.\");}if(message.includes(\"CALL_EXCEPTION\")||message.includes(\"execution reverted\")||message.includes(\"require(false)\")){throw new Error(\"Transfer failed due to contract function mismatch or missing on-chain property.\");}throw error;}}export async function getPropertyHistoryOnChain(hash){const contract=await getReadReadyContract();const records=await contract.getPropertyHistory(hash);return(records||[]).map(r=>({from:r.from,to:r.to,timestamp:Number(r.timestamp)}));}export async function getAllPropertiesOnChain(){const contract=await getReadReadyContract();return await contract.getAllProperties();}export async function getWalletRoleOnChain(){const{contract,signerAddress}=await getWriteReadyContract();const[isRegistrar,adminAddress]=await Promise.all([contract.registrars(signerAddress),contract.admin()]);return{wallet:signerAddress,isRegistrar:Boolean(isRegistrar),adminAddress,isAdmin:String(adminAddress).toLowerCase()===String(signerAddress).toLowerCase()};}export async function grantRegistrarOnChain(registrarAddress){const{contract}=await getWriteReadyContract();const tx=await contract.addRegistrar(registrarAddress);await tx.wait();return tx.hash;}export async function revokeRegistrarOnChain(registrarAddress){const normalized=String(registrarAddress||\"\").trim();if(!normalized){throw new Error(\"Registrar wallet address is required\");}const{contract}=await getWriteReadyContract();const iface=new Interface([\"function removeRegistrar(address registrar)\"]);const data=iface.encodeFunctionData(\"removeRegistrar\",[normalized]);const tx=await contract.runner.sendTransaction({to:contract.target,data});await tx.wait();return tx.hash;}export async function isWalletRegistrarOnChain(walletAddress){const normalized=String(walletAddress||\"\").trim();if(!normalized)return false;const contract=await getReadReadyContract();return Boolean(await contract.registrars(normalized));}export async function getAdminAddressOnChain(){const contract=await getReadReadyContract();return await contract.admin();}export async function getRegistrarStatusOnChain(walletAddress){return await isWalletRegistrarOnChain(walletAddress);}","map":{"version":3,"names":["Interface","ethers","ensureContractCode","ensureCorrectNetwork","ensureWalletConnected","getBrowserProvider","getContractRuntimeConfig","getReadOnlyContract","getWriteContract","getWriteReadyContract","provider","signer","getSigner","contract","signerAddress","getAddress","getReadReadyContract","findEVaultPropertiesByHash","hash","normalizedHash","String","trim","contractAddress","evaultReader","Contract","count","Number","propertyCounter","_unused","matches","i","row","properties","rowHash","ipfsHash","push","id","owner","status","approvalCount","_unused2","findEVaultPropertyByHash","preferredOwner","arguments","length","undefined","normalizedPreferredOwner","toLowerCase","owned","filter","m","sort","a","b","registered","getPropertyStateOnChain","property","ZeroAddress","getOwner","_unused3","documentOwner","_unused4","verified","verifyProperty","_unused5","verifyHash","_unused6","Error","registerPropertyOnChain","isRegistrar","registrars","concat","exists","_unused7","tx","registerProperty","wait","error","message","reason","shortMessage","includes","storeHash","pushHashOnChainWithWallet","intendedOwner","normalizedIntendedOwner","attempts","lastError","registrationTxHash","fragment","_fragment$match","iface","fn","match","data","encodeFunctionData","sendTransaction","to","_lastError","_lastError2","_lastError3","isAddress","_transferError","_transferError2","_transferError3","transferError","transferTxHash","fallbackError","approvePropertyOnChain","approveProperty","verifyPropertyOnChain","_unused8","_unused9","propertyExistsOnChain","_unused0","_unused1","getPropertyOwnerOnChain","_unused10","_unused11","transferPropertyOnChain","newOwner","normalizedOwner","transferProperty","txHash","from","runner","target","fallbackMessage","getPropertyHistoryOnChain","records","getPropertyHistory","map","r","timestamp","getAllPropertiesOnChain","getAllProperties","getWalletRoleOnChain","adminAddress","Promise","all","admin","wallet","Boolean","isAdmin","grantRegistrarOnChain","registrarAddress","addRegistrar","revokeRegistrarOnChain","normalized","isWalletRegistrarOnChain","walletAddress","getAdminAddressOnChain","getRegistrarStatusOnChain"],"sources":["C:/Users/ahmad/OneDrive/Desktop/evault/frontend/src/contract/propertyActions.js"],"sourcesContent":["import { Interface } from \"ethers\";\nimport { ethers } from \"ethers\";\nimport {\n  ensureContractCode,\n  ensureCorrectNetwork,\n  ensureWalletConnected,\n  getBrowserProvider,\n  getContractRuntimeConfig,\n  getReadOnlyContract,\n  getWriteContract,\n} from \"./eth.js\";\n\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return { contract, signerAddress };\n}\n\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\n\nasync function findEVaultPropertiesByHash(hash) {\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) return [];\n\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const { contractAddress } = getContractRuntimeConfig();\n\n  const evaultReader = new ethers.Contract(\n    contractAddress,\n    [\n      \"function propertyCounter() view returns (uint256)\",\n      \"function properties(uint256) view returns (uint256 id,address owner,string ipfsHash,bool registrarApproved,bool notaryApproved,bool authorityApproved,uint256 approvalCount,uint8 status,bool bankVerified)\",\n    ],\n    provider\n  );\n\n  let count = 0;\n  try {\n    count = Number(await evaultReader.propertyCounter());\n  } catch {\n    return [];\n  }\n\n  const matches = [];\n  for (let i = 1; i <= count; i += 1) {\n    try {\n      const row = await evaultReader.properties(i);\n      const rowHash = String(row?.ipfsHash || \"\").trim();\n      if (rowHash && rowHash === normalizedHash) {\n        matches.push({\n          id: Number(row.id || i),\n          owner: String(row.owner || \"\"),\n          ipfsHash: rowHash,\n          status: Number(row.status || 0),\n          approvalCount: Number(row.approvalCount || 0),\n        });\n      }\n    } catch {\n      // continue scan\n    }\n  }\n\n  return matches;\n}\n\nasync function findEVaultPropertyByHash(hash, preferredOwner = \"\") {\n  const matches = await findEVaultPropertiesByHash(hash);\n  if (!matches.length) return null;\n\n  const normalizedPreferredOwner = String(preferredOwner || \"\").trim().toLowerCase();\n  if (normalizedPreferredOwner) {\n    const owned = matches\n      .filter((m) => String(m.owner || \"\").toLowerCase() === normalizedPreferredOwner)\n      .sort((a, b) => b.id - a.id);\n    if (owned.length) return owned[0];\n  }\n\n  // Prefer latest registered record; otherwise latest id.\n  const registered = matches\n    .filter((m) => Number(m.status) === 2)\n    .sort((a, b) => b.id - a.id);\n  if (registered.length) return registered[0];\n\n  return matches.sort((a, b) => b.id - a.id)[0];\n}\n\nexport async function getPropertyStateOnChain(hash, preferredOwner = \"\") {\n  const normalizedHash = String(hash || \"\").trim();\n  const property = await findEVaultPropertyByHash(normalizedHash, preferredOwner);\n  if (property) {\n    return property;\n  }\n\n  const contract = await getReadReadyContract();\n  let owner = ethers.ZeroAddress;\n  try {\n    owner = await contract.getOwner(normalizedHash);\n  } catch {\n    try {\n      owner = await contract.documentOwner(normalizedHash);\n    } catch {\n      owner = ethers.ZeroAddress;\n    }\n  }\n\n  let verified = false;\n  try {\n    verified = await contract.verifyProperty(normalizedHash);\n  } catch {\n    try {\n      verified = await contract.verifyHash(normalizedHash);\n    } catch {\n      verified = false;\n    }\n  }\n\n  if (owner && String(owner).toLowerCase() !== ethers.ZeroAddress.toLowerCase()) {\n    return {\n      id: 0,\n      owner: String(owner),\n      ipfsHash: normalizedHash,\n      status: verified ? 2 : 0,\n      approvalCount: 0,\n    };\n  }\n\n  throw new Error(\"Property hash was not found on-chain.\");\n}\n\nexport async function registerPropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`\n    );\n  }\n\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\n\nexport async function pushHashOnChainWithWallet(hash, intendedOwner = \"\") {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const signerAddress = String(await signer.getAddress()).toLowerCase();\n  const { contractAddress } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedIntendedOwner = String(intendedOwner || \"\").trim().toLowerCase();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n\n  const attempts = [\n    \"function requestRegistration(string ipfsHash)\",\n    \"function registerProperty(string hash)\",\n    \"function storeHash(string _hash)\",\n  ];\n\n  let lastError = null;\n  let registrationTxHash = \"\";\n  for (const fragment of attempts) {\n    try {\n      const iface = new Interface([fragment]);\n      const fn = String(fragment.match(/function\\s+([^(]+)/)?.[1] || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({ to: contractAddress, data });\n      await tx.wait();\n      registrationTxHash = tx.hash;\n      break;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n\n  if (!registrationTxHash) {\n    throw new Error(\n      `Wallet chain push failed: ${String(\n        lastError?.reason || lastError?.shortMessage || lastError?.message || \"unknown error\"\n      )}`\n    );\n  }\n\n  // If reviewer wallet pushed the hash, transfer ownership to intended owner immediately.\n  if (\n    normalizedIntendedOwner &&\n    ethers.isAddress(normalizedIntendedOwner) &&\n    normalizedIntendedOwner !== signerAddress\n  ) {\n    let transferError = null;\n    try {\n      const iface = new Interface([\n        \"function transferProperty(string hash, address newOwner)\",\n      ]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [\n        normalizedHash,\n        normalizedIntendedOwner,\n      ]);\n      const tx = await signer.sendTransaction({ to: contractAddress, data });\n      await tx.wait();\n      return { registrationTxHash, transferTxHash: tx.hash };\n    } catch (error) {\n      transferError = error;\n    }\n\n    // eVault fallback: transferProperty(uint256,address)\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash, signerAddress);\n      if (property?.id) {\n        const iface = new Interface([\n          \"function transferProperty(uint256 propertyId, address newOwner)\",\n        ]);\n        const data = iface.encodeFunctionData(\"transferProperty\", [\n          property.id,\n          normalizedIntendedOwner,\n        ]);\n        const tx = await signer.sendTransaction({ to: contractAddress, data });\n        await tx.wait();\n        return { registrationTxHash, transferTxHash: tx.hash };\n      }\n    } catch (fallbackError) {\n      transferError = fallbackError;\n    }\n\n    throw new Error(\n      `Hash pushed, but owner transfer to intended wallet failed: ${String(\n        transferError?.reason ||\n          transferError?.shortMessage ||\n          transferError?.message ||\n          \"unknown error\"\n      )}`\n    );\n  }\n\n  return { registrationTxHash, transferTxHash: \"\" };\n}\n\nexport async function approvePropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`\n    );\n  }\n\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    try {\n      return await contract.documentOwner(hash);\n    } catch {\n      const property = await findEVaultPropertyByHash(hash);\n      return property?.owner || \"0x0000000000000000000000000000000000000000\";\n    }\n  }\n}\n\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n  } catch (error) {\n    // Fallback for eVault contract that uses transferProperty(uint256,address).\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash, signerAddress);\n      if (!property?.id) {\n        throw new Error(\"Property hash not found in eVault contract.\");\n      }\n      const iface = new Interface([\n        \"function transferProperty(uint256 propertyId, address newOwner)\",\n      ]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [\n        property.id,\n        normalizedOwner,\n      ]);\n      const tx = await contract.runner.sendTransaction({\n        to: contract.target,\n        data,\n      });\n      await tx.wait();\n      return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n    } catch (fallbackError) {\n      const fallbackMessage = String(\n        fallbackError?.reason ||\n          fallbackError?.shortMessage ||\n          fallbackError?.message ||\n          \"\"\n      );\n      if (fallbackMessage.includes(\"Only current owner\")) {\n        throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n      }\n      if (fallbackMessage.includes(\"Invalid owner\") || fallbackMessage.includes(\"Invalid new owner\")) {\n        throw new Error(\"Invalid recipient wallet address.\");\n      }\n      if (fallbackMessage.includes(\"Property hash not found in eVault contract\")) {\n        throw new Error(\"Property hash was not found on-chain.\");\n      }\n    }\n\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\n        \"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\"\n      );\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    if (\n      message.includes(\"CALL_EXCEPTION\") ||\n      message.includes(\"execution reverted\") ||\n      message.includes(\"require(false)\")\n    ) {\n      throw new Error(\"Transfer failed due to contract function mismatch or missing on-chain property.\");\n    }\n    throw error;\n  }\n}\n\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map((r) => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp),\n  }));\n}\n\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\n\nexport async function getWalletRoleOnChain() {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([\n    contract.registrars(signerAddress),\n    contract.admin(),\n  ]);\n\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase(),\n  };\n}\n\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const { contract } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n\n  const { contract } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data,\n  });\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\n\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\n\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}