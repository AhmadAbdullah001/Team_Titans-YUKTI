{"ast":null,"code":"import{Interface}from\"ethers\";import{ensureContractCode,ensureCorrectNetwork,ensureWalletConnected,getBrowserProvider,getContractRuntimeConfig,getReadOnlyContract,getWriteContract}from\"./eth.js\";async function getWriteReadyContract(){const provider=await getBrowserProvider();await ensureWalletConnected(provider);await ensureCorrectNetwork(provider);await ensureContractCode(provider);const signer=await provider.getSigner();const contract=getWriteContract(signer);const signerAddress=await signer.getAddress();return{contract,signerAddress};}async function getReadReadyContract(){const provider=await getBrowserProvider();await ensureWalletConnected(provider);await ensureCorrectNetwork(provider);await ensureContractCode(provider);return getReadOnlyContract(provider);}export async function registerPropertyOnChain(hash){const{contract,signerAddress}=await getWriteReadyContract();const isRegistrar=await contract.registrars(signerAddress);if(isRegistrar){throw new Error(\"Connected wallet \".concat(signerAddress,\" is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.\"));}try{const exists=await contract.verifyHash(hash);if(exists){return\"already-registered\";}}catch(_unused){// continue and try write path\n}try{const tx=await contract.registerProperty(hash);await tx.wait();return tx.hash;}catch(error){const message=String((error===null||error===void 0?void 0:error.reason)||(error===null||error===void 0?void 0:error.shortMessage)||(error===null||error===void 0?void 0:error.message)||\"\");if(message.toLowerCase().includes(\"already exists\")){return\"already-registered\";}if(message.includes(\"is not a function\")||message.includes(\"missing revert data\")){const tx=await contract.storeHash(hash);await tx.wait();return tx.hash;}throw error;}}export async function pushHashOnChainWithWallet(hash){var _lastError,_lastError2,_lastError3;const provider=await getBrowserProvider();await ensureWalletConnected(provider);await ensureCorrectNetwork(provider);await ensureContractCode(provider);const signer=await provider.getSigner();const{contractAddress}=getContractRuntimeConfig();const normalizedHash=String(hash||\"\").trim();if(!normalizedHash){throw new Error(\"Property hash is required\");}const attempts=[\"function requestRegistration(string ipfsHash)\",\"function registerProperty(string hash)\",\"function storeHash(string _hash)\"];let lastError=null;for(const fragment of attempts){try{var _fragment$match;const iface=new Interface([fragment]);const fn=String(((_fragment$match=fragment.match(/function\\s+([^(]+)/))===null||_fragment$match===void 0?void 0:_fragment$match[1])||\"\").trim();const data=iface.encodeFunctionData(fn,[normalizedHash]);const tx=await signer.sendTransaction({to:contractAddress,data});await tx.wait();return tx.hash;}catch(error){lastError=error;}}throw new Error(\"Wallet chain push failed: \".concat(String(((_lastError=lastError)===null||_lastError===void 0?void 0:_lastError.reason)||((_lastError2=lastError)===null||_lastError2===void 0?void 0:_lastError2.shortMessage)||((_lastError3=lastError)===null||_lastError3===void 0?void 0:_lastError3.message)||\"unknown error\")));}export async function approvePropertyOnChain(hash){const{contract,signerAddress}=await getWriteReadyContract();const isRegistrar=await contract.registrars(signerAddress);if(!isRegistrar){throw new Error(\"Connected wallet \".concat(signerAddress,\" is not on-chain registrar. Ask admin to call addRegistrar.\"));}const tx=await contract.approveProperty(hash);await tx.wait();return tx.hash;}export async function verifyPropertyOnChain(hash){const contract=await getReadReadyContract();try{return await contract.verifyProperty(hash);}catch(_unused2){try{return await contract.verifyHash(hash);}catch(_unused3){return false;}}}export async function propertyExistsOnChain(hash){const contract=await getReadReadyContract();try{return await contract.verifyHash(hash);}catch(_unused4){try{const owner=await contract.getOwner(hash);return owner&&owner!==\"0x0000000000000000000000000000000000000000\";}catch(_unused5){return null;}}}export async function getPropertyOwnerOnChain(hash){const contract=await getReadReadyContract();try{return await contract.getOwner(hash);}catch(_unused6){return await contract.documentOwner(hash);}}export async function transferPropertyOnChain(hash,newOwner){const{contract,signerAddress}=await getWriteReadyContract();const normalizedHash=String(hash||\"\").trim();const normalizedOwner=String(newOwner||\"\").trim();if(!normalizedHash){throw new Error(\"Property hash is required\");}if(!normalizedOwner){throw new Error(\"New owner wallet address is required\");}try{const tx=await contract.transferProperty(normalizedHash,normalizedOwner);await tx.wait();return{txHash:tx.hash,from:signerAddress,to:normalizedOwner};}catch(error){const message=String((error===null||error===void 0?void 0:error.reason)||(error===null||error===void 0?void 0:error.shortMessage)||(error===null||error===void 0?void 0:error.message)||\"\");if(message.includes(\"Property not found\")){throw new Error(\"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\");}if(message.includes(\"Only current owner\")){throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");}if(message.includes(\"Invalid new owner\")){throw new Error(\"Invalid recipient wallet address.\");}if(message.includes(\"Already owner\")){throw new Error(\"Recipient wallet is already the current owner.\");}throw error;}}export async function getPropertyHistoryOnChain(hash){const contract=await getReadReadyContract();const records=await contract.getPropertyHistory(hash);return(records||[]).map(r=>({from:r.from,to:r.to,timestamp:Number(r.timestamp)}));}export async function getAllPropertiesOnChain(){const contract=await getReadReadyContract();return await contract.getAllProperties();}export async function getWalletRoleOnChain(){const{contract,signerAddress}=await getWriteReadyContract();const[isRegistrar,adminAddress]=await Promise.all([contract.registrars(signerAddress),contract.admin()]);return{wallet:signerAddress,isRegistrar:Boolean(isRegistrar),adminAddress,isAdmin:String(adminAddress).toLowerCase()===String(signerAddress).toLowerCase()};}export async function grantRegistrarOnChain(registrarAddress){const{contract}=await getWriteReadyContract();const tx=await contract.addRegistrar(registrarAddress);await tx.wait();return tx.hash;}export async function revokeRegistrarOnChain(registrarAddress){const normalized=String(registrarAddress||\"\").trim();if(!normalized){throw new Error(\"Registrar wallet address is required\");}const{contract}=await getWriteReadyContract();const iface=new Interface([\"function removeRegistrar(address registrar)\"]);const data=iface.encodeFunctionData(\"removeRegistrar\",[normalized]);const tx=await contract.runner.sendTransaction({to:contract.target,data});await tx.wait();return tx.hash;}export async function isWalletRegistrarOnChain(walletAddress){const normalized=String(walletAddress||\"\").trim();if(!normalized)return false;const contract=await getReadReadyContract();return Boolean(await contract.registrars(normalized));}export async function getAdminAddressOnChain(){const contract=await getReadReadyContract();return await contract.admin();}export async function getRegistrarStatusOnChain(walletAddress){return await isWalletRegistrarOnChain(walletAddress);}","map":{"version":3,"names":["Interface","ensureContractCode","ensureCorrectNetwork","ensureWalletConnected","getBrowserProvider","getContractRuntimeConfig","getReadOnlyContract","getWriteContract","getWriteReadyContract","provider","signer","getSigner","contract","signerAddress","getAddress","getReadReadyContract","registerPropertyOnChain","hash","isRegistrar","registrars","Error","concat","exists","verifyHash","_unused","tx","registerProperty","wait","error","message","String","reason","shortMessage","toLowerCase","includes","storeHash","pushHashOnChainWithWallet","_lastError","_lastError2","_lastError3","contractAddress","normalizedHash","trim","attempts","lastError","fragment","_fragment$match","iface","fn","match","data","encodeFunctionData","sendTransaction","to","approvePropertyOnChain","approveProperty","verifyPropertyOnChain","verifyProperty","_unused2","_unused3","propertyExistsOnChain","_unused4","owner","getOwner","_unused5","getPropertyOwnerOnChain","_unused6","documentOwner","transferPropertyOnChain","newOwner","normalizedOwner","transferProperty","txHash","from","getPropertyHistoryOnChain","records","getPropertyHistory","map","r","timestamp","Number","getAllPropertiesOnChain","getAllProperties","getWalletRoleOnChain","adminAddress","Promise","all","admin","wallet","Boolean","isAdmin","grantRegistrarOnChain","registrarAddress","addRegistrar","revokeRegistrarOnChain","normalized","runner","target","isWalletRegistrarOnChain","walletAddress","getAdminAddressOnChain","getRegistrarStatusOnChain"],"sources":["C:/Users/ahmad/OneDrive/Desktop/evault/frontend/src/contract/propertyActions.js"],"sourcesContent":["import { Interface } from \"ethers\";\nimport {\n  ensureContractCode,\n  ensureCorrectNetwork,\n  ensureWalletConnected,\n  getBrowserProvider,\n  getContractRuntimeConfig,\n  getReadOnlyContract,\n  getWriteContract,\n} from \"./eth.js\";\n\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return { contract, signerAddress };\n}\n\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\n\nexport async function registerPropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`\n    );\n  }\n\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\n\nexport async function pushHashOnChainWithWallet(hash) {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const { contractAddress } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n\n  const attempts = [\n    \"function requestRegistration(string ipfsHash)\",\n    \"function registerProperty(string hash)\",\n    \"function storeHash(string _hash)\",\n  ];\n\n  let lastError = null;\n  for (const fragment of attempts) {\n    try {\n      const iface = new Interface([fragment]);\n      const fn = String(fragment.match(/function\\s+([^(]+)/)?.[1] || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({ to: contractAddress, data });\n      await tx.wait();\n      return tx.hash;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n\n  throw new Error(\n    `Wallet chain push failed: ${String(\n      lastError?.reason || lastError?.shortMessage || lastError?.message || \"unknown error\"\n    )}`\n  );\n}\n\nexport async function approvePropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`\n    );\n  }\n\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    return await contract.documentOwner(hash);\n  }\n}\n\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\n        \"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\"\n      );\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    throw error;\n  }\n}\n\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map((r) => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp),\n  }));\n}\n\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\n\nexport async function getWalletRoleOnChain() {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([\n    contract.registrars(signerAddress),\n    contract.admin(),\n  ]);\n\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase(),\n  };\n}\n\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const { contract } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n\n  const { contract } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data,\n  });\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\n\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\n\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}