{"ast":null,"code":"import { Interface } from \"ethers\";\nimport { ethers } from \"ethers\";\nimport { ensureContractCode, ensureCorrectNetwork, ensureWalletConnected, getBrowserProvider, getContractRuntimeConfig, getReadOnlyContract, getWriteContract } from \"./eth.js\";\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return {\n    contract,\n    signerAddress\n  };\n}\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\nasync function findEVaultPropertiesByHash(hash) {\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) return [];\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const {\n    contractAddress\n  } = getContractRuntimeConfig();\n  const evaultReader = new ethers.Contract(contractAddress, [\"function propertyCounter() view returns (uint256)\", \"function properties(uint256) view returns (uint256 id,address owner,string ipfsHash,bool registrarApproved,bool notaryApproved,bool authorityApproved,uint256 approvalCount,uint8 status,bool bankVerified)\"], provider);\n  let count = 0;\n  try {\n    count = Number(await evaultReader.propertyCounter());\n  } catch {\n    return [];\n  }\n  const matches = [];\n  for (let i = 1; i <= count; i += 1) {\n    try {\n      const row = await evaultReader.properties(i);\n      const rowHash = String((row === null || row === void 0 ? void 0 : row.ipfsHash) || \"\").trim();\n      if (rowHash && rowHash === normalizedHash) {\n        matches.push({\n          id: Number(row.id || i),\n          owner: String(row.owner || \"\"),\n          ipfsHash: rowHash,\n          status: Number(row.status || 0),\n          approvalCount: Number(row.approvalCount || 0)\n        });\n      }\n    } catch {\n      // continue scan\n    }\n  }\n  return matches;\n}\nasync function findEVaultPropertyByHash(hash, preferredOwner = \"\") {\n  const matches = await findEVaultPropertiesByHash(hash);\n  if (!matches.length) return null;\n  const normalizedPreferredOwner = String(preferredOwner || \"\").trim().toLowerCase();\n  if (normalizedPreferredOwner) {\n    const owned = matches.filter(m => String(m.owner || \"\").toLowerCase() === normalizedPreferredOwner).sort((a, b) => b.id - a.id);\n    if (owned.length) return owned[0];\n  }\n\n  // Prefer latest registered record; otherwise latest id.\n  const registered = matches.filter(m => Number(m.status) === 2).sort((a, b) => b.id - a.id);\n  if (registered.length) return registered[0];\n  return matches.sort((a, b) => b.id - a.id)[0];\n}\nexport async function registerPropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`);\n  }\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\nexport async function pushHashOnChainWithWallet(hash) {\n  var _lastError, _lastError2, _lastError3;\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const {\n    contractAddress\n  } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  const attempts = [\"function requestRegistration(string ipfsHash)\", \"function registerProperty(string hash)\", \"function storeHash(string _hash)\"];\n  let lastError = null;\n  for (const fragment of attempts) {\n    try {\n      var _fragment$match;\n      const iface = new Interface([fragment]);\n      const fn = String(((_fragment$match = fragment.match(/function\\s+([^(]+)/)) === null || _fragment$match === void 0 ? void 0 : _fragment$match[1]) || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({\n        to: contractAddress,\n        data\n      });\n      await tx.wait();\n      return tx.hash;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n  throw new Error(`Wallet chain push failed: ${String(((_lastError = lastError) === null || _lastError === void 0 ? void 0 : _lastError.reason) || ((_lastError2 = lastError) === null || _lastError2 === void 0 ? void 0 : _lastError2.shortMessage) || ((_lastError3 = lastError) === null || _lastError3 === void 0 ? void 0 : _lastError3.message) || \"unknown error\")}`);\n}\nexport async function approvePropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`);\n  }\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    try {\n      return await contract.documentOwner(hash);\n    } catch {\n      const property = await findEVaultPropertyByHash(hash);\n      return (property === null || property === void 0 ? void 0 : property.owner) || \"0x0000000000000000000000000000000000000000\";\n    }\n  }\n}\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return {\n      txHash: tx.hash,\n      from: signerAddress,\n      to: normalizedOwner\n    };\n  } catch (error) {\n    // Fallback for eVault contract that uses transferProperty(uint256,address).\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash, signerAddress);\n      if (!(property !== null && property !== void 0 && property.id)) {\n        throw new Error(\"Property hash not found in eVault contract.\");\n      }\n      const iface = new Interface([\"function transferProperty(uint256 propertyId, address newOwner)\"]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [property.id, normalizedOwner]);\n      const tx = await contract.runner.sendTransaction({\n        to: contract.target,\n        data\n      });\n      await tx.wait();\n      return {\n        txHash: tx.hash,\n        from: signerAddress,\n        to: normalizedOwner\n      };\n    } catch (fallbackError) {\n      const fallbackMessage = String((fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.reason) || (fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.shortMessage) || (fallbackError === null || fallbackError === void 0 ? void 0 : fallbackError.message) || \"\");\n      if (fallbackMessage.includes(\"Only current owner\")) {\n        throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n      }\n      if (fallbackMessage.includes(\"Invalid owner\") || fallbackMessage.includes(\"Invalid new owner\")) {\n        throw new Error(\"Invalid recipient wallet address.\");\n      }\n      if (fallbackMessage.includes(\"Property hash not found in eVault contract\")) {\n        throw new Error(\"Property hash was not found on-chain.\");\n      }\n    }\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\");\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    if (message.includes(\"CALL_EXCEPTION\") || message.includes(\"execution reverted\") || message.includes(\"require(false)\")) {\n      throw new Error(\"Transfer failed due to contract function mismatch or missing on-chain property.\");\n    }\n    throw error;\n  }\n}\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map(r => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp)\n  }));\n}\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\nexport async function getWalletRoleOnChain() {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([contract.registrars(signerAddress), contract.admin()]);\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase()\n  };\n}\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data\n  });\n  await tx.wait();\n  return tx.hash;\n}\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}","map":{"version":3,"names":["Interface","ethers","ensureContractCode","ensureCorrectNetwork","ensureWalletConnected","getBrowserProvider","getContractRuntimeConfig","getReadOnlyContract","getWriteContract","getWriteReadyContract","provider","signer","getSigner","contract","signerAddress","getAddress","getReadReadyContract","findEVaultPropertiesByHash","hash","normalizedHash","String","trim","contractAddress","evaultReader","Contract","count","Number","propertyCounter","matches","i","row","properties","rowHash","ipfsHash","push","id","owner","status","approvalCount","findEVaultPropertyByHash","preferredOwner","length","normalizedPreferredOwner","toLowerCase","owned","filter","m","sort","a","b","registered","registerPropertyOnChain","isRegistrar","registrars","Error","exists","verifyHash","tx","registerProperty","wait","error","message","reason","shortMessage","includes","storeHash","pushHashOnChainWithWallet","_lastError","_lastError2","_lastError3","attempts","lastError","fragment","_fragment$match","iface","fn","match","data","encodeFunctionData","sendTransaction","to","approvePropertyOnChain","approveProperty","verifyPropertyOnChain","verifyProperty","propertyExistsOnChain","getOwner","getPropertyOwnerOnChain","documentOwner","property","transferPropertyOnChain","newOwner","normalizedOwner","transferProperty","txHash","from","runner","target","fallbackError","fallbackMessage","getPropertyHistoryOnChain","records","getPropertyHistory","map","r","timestamp","getAllPropertiesOnChain","getAllProperties","getWalletRoleOnChain","adminAddress","Promise","all","admin","wallet","Boolean","isAdmin","grantRegistrarOnChain","registrarAddress","addRegistrar","revokeRegistrarOnChain","normalized","isWalletRegistrarOnChain","walletAddress","getAdminAddressOnChain","getRegistrarStatusOnChain"],"sources":["C:/Users/ahmad/OneDrive/Desktop/evault/frontend/src/contract/propertyActions.js"],"sourcesContent":["import { Interface } from \"ethers\";\nimport { ethers } from \"ethers\";\nimport {\n  ensureContractCode,\n  ensureCorrectNetwork,\n  ensureWalletConnected,\n  getBrowserProvider,\n  getContractRuntimeConfig,\n  getReadOnlyContract,\n  getWriteContract,\n} from \"./eth.js\";\n\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return { contract, signerAddress };\n}\n\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\n\nasync function findEVaultPropertiesByHash(hash) {\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) return [];\n\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const { contractAddress } = getContractRuntimeConfig();\n\n  const evaultReader = new ethers.Contract(\n    contractAddress,\n    [\n      \"function propertyCounter() view returns (uint256)\",\n      \"function properties(uint256) view returns (uint256 id,address owner,string ipfsHash,bool registrarApproved,bool notaryApproved,bool authorityApproved,uint256 approvalCount,uint8 status,bool bankVerified)\",\n    ],\n    provider\n  );\n\n  let count = 0;\n  try {\n    count = Number(await evaultReader.propertyCounter());\n  } catch {\n    return [];\n  }\n\n  const matches = [];\n  for (let i = 1; i <= count; i += 1) {\n    try {\n      const row = await evaultReader.properties(i);\n      const rowHash = String(row?.ipfsHash || \"\").trim();\n      if (rowHash && rowHash === normalizedHash) {\n        matches.push({\n          id: Number(row.id || i),\n          owner: String(row.owner || \"\"),\n          ipfsHash: rowHash,\n          status: Number(row.status || 0),\n          approvalCount: Number(row.approvalCount || 0),\n        });\n      }\n    } catch {\n      // continue scan\n    }\n  }\n\n  return matches;\n}\n\nasync function findEVaultPropertyByHash(hash, preferredOwner = \"\") {\n  const matches = await findEVaultPropertiesByHash(hash);\n  if (!matches.length) return null;\n\n  const normalizedPreferredOwner = String(preferredOwner || \"\").trim().toLowerCase();\n  if (normalizedPreferredOwner) {\n    const owned = matches\n      .filter((m) => String(m.owner || \"\").toLowerCase() === normalizedPreferredOwner)\n      .sort((a, b) => b.id - a.id);\n    if (owned.length) return owned[0];\n  }\n\n  // Prefer latest registered record; otherwise latest id.\n  const registered = matches\n    .filter((m) => Number(m.status) === 2)\n    .sort((a, b) => b.id - a.id);\n  if (registered.length) return registered[0];\n\n  return matches.sort((a, b) => b.id - a.id)[0];\n}\n\nexport async function registerPropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`\n    );\n  }\n\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\n\nexport async function pushHashOnChainWithWallet(hash) {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const { contractAddress } = getContractRuntimeConfig();\n  const normalizedHash = String(hash || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n\n  const attempts = [\n    \"function requestRegistration(string ipfsHash)\",\n    \"function registerProperty(string hash)\",\n    \"function storeHash(string _hash)\",\n  ];\n\n  let lastError = null;\n  for (const fragment of attempts) {\n    try {\n      const iface = new Interface([fragment]);\n      const fn = String(fragment.match(/function\\s+([^(]+)/)?.[1] || \"\").trim();\n      const data = iface.encodeFunctionData(fn, [normalizedHash]);\n      const tx = await signer.sendTransaction({ to: contractAddress, data });\n      await tx.wait();\n      return tx.hash;\n    } catch (error) {\n      lastError = error;\n    }\n  }\n\n  throw new Error(\n    `Wallet chain push failed: ${String(\n      lastError?.reason || lastError?.shortMessage || lastError?.message || \"unknown error\"\n    )}`\n  );\n}\n\nexport async function approvePropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`\n    );\n  }\n\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    try {\n      return await contract.verifyHash(hash);\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    try {\n      return await contract.documentOwner(hash);\n    } catch {\n      const property = await findEVaultPropertyByHash(hash);\n      return property?.owner || \"0x0000000000000000000000000000000000000000\";\n    }\n  }\n}\n\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n  } catch (error) {\n    // Fallback for eVault contract that uses transferProperty(uint256,address).\n    try {\n      const property = await findEVaultPropertyByHash(normalizedHash, signerAddress);\n      if (!property?.id) {\n        throw new Error(\"Property hash not found in eVault contract.\");\n      }\n      const iface = new Interface([\n        \"function transferProperty(uint256 propertyId, address newOwner)\",\n      ]);\n      const data = iface.encodeFunctionData(\"transferProperty\", [\n        property.id,\n        normalizedOwner,\n      ]);\n      const tx = await contract.runner.sendTransaction({\n        to: contract.target,\n        data,\n      });\n      await tx.wait();\n      return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n    } catch (fallbackError) {\n      const fallbackMessage = String(\n        fallbackError?.reason ||\n          fallbackError?.shortMessage ||\n          fallbackError?.message ||\n          \"\"\n      );\n      if (fallbackMessage.includes(\"Only current owner\")) {\n        throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n      }\n      if (fallbackMessage.includes(\"Invalid owner\") || fallbackMessage.includes(\"Invalid new owner\")) {\n        throw new Error(\"Invalid recipient wallet address.\");\n      }\n      if (fallbackMessage.includes(\"Property hash not found in eVault contract\")) {\n        throw new Error(\"Property hash was not found on-chain.\");\n      }\n    }\n\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\n        \"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\"\n      );\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    if (\n      message.includes(\"CALL_EXCEPTION\") ||\n      message.includes(\"execution reverted\") ||\n      message.includes(\"require(false)\")\n    ) {\n      throw new Error(\"Transfer failed due to contract function mismatch or missing on-chain property.\");\n    }\n    throw error;\n  }\n}\n\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map((r) => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp),\n  }));\n}\n\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\n\nexport async function getWalletRoleOnChain() {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([\n    contract.registrars(signerAddress),\n    contract.admin(),\n  ]);\n\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase(),\n  };\n}\n\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const { contract } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n\n  const { contract } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data,\n  });\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\n\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\n\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}