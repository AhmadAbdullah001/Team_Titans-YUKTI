{"ast":null,"code":"import { Interface } from \"ethers\";\nimport { ensureContractCode, ensureCorrectNetwork, ensureWalletConnected, getBrowserProvider, getReadOnlyContract, getWriteContract } from \"./eth.js\";\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return {\n    contract,\n    signerAddress\n  };\n}\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\nexport async function registerPropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`);\n  }\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\nexport async function approvePropertyOnChain(hash) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(`Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`);\n  }\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    return await contract.verifyHash(hash);\n  }\n}\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    return await contract.documentOwner(hash);\n  }\n}\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return {\n      txHash: tx.hash,\n      from: signerAddress,\n      to: normalizedOwner\n    };\n  } catch (error) {\n    const message = String((error === null || error === void 0 ? void 0 : error.reason) || (error === null || error === void 0 ? void 0 : error.shortMessage) || (error === null || error === void 0 ? void 0 : error.message) || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\");\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    throw error;\n  }\n}\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map(r => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp)\n  }));\n}\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\nexport async function getWalletRoleOnChain() {\n  const {\n    contract,\n    signerAddress\n  } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([contract.registrars(signerAddress), contract.admin()]);\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase()\n  };\n}\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n  const {\n    contract\n  } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data\n  });\n  await tx.wait();\n  return tx.hash;\n}\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}","map":{"version":3,"names":["Interface","ensureContractCode","ensureCorrectNetwork","ensureWalletConnected","getBrowserProvider","getReadOnlyContract","getWriteContract","getWriteReadyContract","provider","signer","getSigner","contract","signerAddress","getAddress","getReadReadyContract","registerPropertyOnChain","hash","isRegistrar","registrars","Error","exists","verifyHash","tx","registerProperty","wait","error","message","String","reason","shortMessage","toLowerCase","includes","storeHash","approvePropertyOnChain","approveProperty","verifyPropertyOnChain","verifyProperty","propertyExistsOnChain","owner","getOwner","getPropertyOwnerOnChain","documentOwner","transferPropertyOnChain","newOwner","normalizedHash","trim","normalizedOwner","transferProperty","txHash","from","to","getPropertyHistoryOnChain","records","getPropertyHistory","map","r","timestamp","Number","getAllPropertiesOnChain","getAllProperties","getWalletRoleOnChain","adminAddress","Promise","all","admin","wallet","Boolean","isAdmin","grantRegistrarOnChain","registrarAddress","addRegistrar","revokeRegistrarOnChain","normalized","iface","data","encodeFunctionData","runner","sendTransaction","target","isWalletRegistrarOnChain","walletAddress","getAdminAddressOnChain","getRegistrarStatusOnChain"],"sources":["C:/Users/ahmad/OneDrive/Desktop/evault/frontend/src/contract/propertyActions.js"],"sourcesContent":["import { Interface } from \"ethers\";\nimport {\n  ensureContractCode,\n  ensureCorrectNetwork,\n  ensureWalletConnected,\n  getBrowserProvider,\n  getReadOnlyContract,\n  getWriteContract,\n} from \"./eth.js\";\n\nasync function getWriteReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  const signer = await provider.getSigner();\n  const contract = getWriteContract(signer);\n  const signerAddress = await signer.getAddress();\n  return { contract, signerAddress };\n}\n\nasync function getReadReadyContract() {\n  const provider = await getBrowserProvider();\n  await ensureWalletConnected(provider);\n  await ensureCorrectNetwork(provider);\n  await ensureContractCode(provider);\n  return getReadOnlyContract(provider);\n}\n\nexport async function registerPropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is registered as registrar on-chain. Switch to a non-registrar wallet to upload as citizen.`\n    );\n  }\n\n  try {\n    const exists = await contract.verifyHash(hash);\n    if (exists) {\n      return \"already-registered\";\n    }\n  } catch {\n    // continue and try write path\n  }\n\n  try {\n    const tx = await contract.registerProperty(hash);\n    await tx.wait();\n    return tx.hash;\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.toLowerCase().includes(\"already exists\")) {\n      return \"already-registered\";\n    }\n    if (message.includes(\"is not a function\") || message.includes(\"missing revert data\")) {\n      const tx = await contract.storeHash(hash);\n      await tx.wait();\n      return tx.hash;\n    }\n    throw error;\n  }\n}\n\nexport async function approvePropertyOnChain(hash) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n\n  const isRegistrar = await contract.registrars(signerAddress);\n  if (!isRegistrar) {\n    throw new Error(\n      `Connected wallet ${signerAddress} is not on-chain registrar. Ask admin to call addRegistrar.`\n    );\n  }\n\n  const tx = await contract.approveProperty(hash);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function verifyPropertyOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyProperty(hash);\n  } catch {\n    return await contract.verifyHash(hash);\n  }\n}\n\nexport async function propertyExistsOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.verifyHash(hash);\n  } catch {\n    try {\n      const owner = await contract.getOwner(hash);\n      return owner && owner !== \"0x0000000000000000000000000000000000000000\";\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport async function getPropertyOwnerOnChain(hash) {\n  const contract = await getReadReadyContract();\n  try {\n    return await contract.getOwner(hash);\n  } catch {\n    return await contract.documentOwner(hash);\n  }\n}\n\nexport async function transferPropertyOnChain(hash, newOwner) {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const normalizedHash = String(hash || \"\").trim();\n  const normalizedOwner = String(newOwner || \"\").trim();\n\n  if (!normalizedHash) {\n    throw new Error(\"Property hash is required\");\n  }\n  if (!normalizedOwner) {\n    throw new Error(\"New owner wallet address is required\");\n  }\n\n  try {\n    const tx = await contract.transferProperty(normalizedHash, normalizedOwner);\n    await tx.wait();\n    return { txHash: tx.hash, from: signerAddress, to: normalizedOwner };\n  } catch (error) {\n    const message = String(error?.reason || error?.shortMessage || error?.message || \"\");\n    if (message.includes(\"Property not found\")) {\n      throw new Error(\n        \"Property hash not found on the current blockchain. Register this hash on-chain before transfer.\"\n      );\n    }\n    if (message.includes(\"Only current owner\")) {\n      throw new Error(\"Connected wallet is not the current on-chain owner of this property.\");\n    }\n    if (message.includes(\"Invalid new owner\")) {\n      throw new Error(\"Invalid recipient wallet address.\");\n    }\n    if (message.includes(\"Already owner\")) {\n      throw new Error(\"Recipient wallet is already the current owner.\");\n    }\n    throw error;\n  }\n}\n\nexport async function getPropertyHistoryOnChain(hash) {\n  const contract = await getReadReadyContract();\n  const records = await contract.getPropertyHistory(hash);\n  return (records || []).map((r) => ({\n    from: r.from,\n    to: r.to,\n    timestamp: Number(r.timestamp),\n  }));\n}\n\nexport async function getAllPropertiesOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.getAllProperties();\n}\n\nexport async function getWalletRoleOnChain() {\n  const { contract, signerAddress } = await getWriteReadyContract();\n  const [isRegistrar, adminAddress] = await Promise.all([\n    contract.registrars(signerAddress),\n    contract.admin(),\n  ]);\n\n  return {\n    wallet: signerAddress,\n    isRegistrar: Boolean(isRegistrar),\n    adminAddress,\n    isAdmin: String(adminAddress).toLowerCase() === String(signerAddress).toLowerCase(),\n  };\n}\n\nexport async function grantRegistrarOnChain(registrarAddress) {\n  const { contract } = await getWriteReadyContract();\n  const tx = await contract.addRegistrar(registrarAddress);\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function revokeRegistrarOnChain(registrarAddress) {\n  const normalized = String(registrarAddress || \"\").trim();\n  if (!normalized) {\n    throw new Error(\"Registrar wallet address is required\");\n  }\n\n  const { contract } = await getWriteReadyContract();\n  const iface = new Interface([\"function removeRegistrar(address registrar)\"]);\n  const data = iface.encodeFunctionData(\"removeRegistrar\", [normalized]);\n\n  const tx = await contract.runner.sendTransaction({\n    to: contract.target,\n    data,\n  });\n  await tx.wait();\n  return tx.hash;\n}\n\nexport async function isWalletRegistrarOnChain(walletAddress) {\n  const normalized = String(walletAddress || \"\").trim();\n  if (!normalized) return false;\n  const contract = await getReadReadyContract();\n  return Boolean(await contract.registrars(normalized));\n}\n\nexport async function getAdminAddressOnChain() {\n  const contract = await getReadReadyContract();\n  return await contract.admin();\n}\n\nexport async function getRegistrarStatusOnChain(walletAddress) {\n  return await isWalletRegistrarOnChain(walletAddress);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}